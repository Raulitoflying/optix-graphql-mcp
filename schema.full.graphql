enum AccountStatus {
  ACTIVE
  COMMUNITY
  DELETED
  HIDDEN
  INACTIVE
  UNCONFIRMED
  UNKNOWN
}

enum AccountWidget {
  ACCOUNT_BALANCE_KPI
  ACCOUNT_PLANS_COUNT_KPI
  ACTIVE_ACCOUNT_PLANS_COUNT_KPI
  ACTIVE_ASSIGNMENTS_COUNT_KPI
  ALLOWANCE
  ASSIGNMENTS
  ASSIGNMENTS_COUNT_KPI
  AUTOMATION_ENROLLMENTS
  AVG_MONTHLY_SPEND_KPI
  BILLING_DETAILS
  BOOKINGS
  BOOKINGS_COUNT_KPI
  CHECKINS
  CHECKINS_COUNT_KPI
  CONFIRMED_BOOKINGS_COUNT_KPI
  DOCUMENTS
  DOCUMENTS_COUNT_KPI
  GENERAL_DETAILS
  INBOX
  INVOICES
  INVOICES_COUNT_KPI
  ISSUES_COUNT_KPI
  NOTES
  PASSES
  PASSES_COUNT_KPI
  PAYMENT_METHODS
  PLANS
  PRODUCT_SALES
  PRODUCT_SALES_COUNT_KPI
  RELATED_ACCOUNTS
  SKILLS
  TASKS
  TERMS
  TOTAL_REVENUE_KPI
  WALLET_ACCESSES_COUNT_KPI
}

enum AdditionalChargeMode {
# Invoice, due on the following billing date
  FOLLOWING_BILLING_DATE

# Charge upfront
  NOW

# Invoice, due today
  TODAY
}

enum ConditionOperation {
# Empty operation, requires 1 parameter
  EMPTY

# Not empty operation, requires 1 parameter
  NOT_EMPTY

# Equals operation, requires 2 parameters
  EQUALS

# Equals operation ignoring years, requires 2 date parameters
  EQUAL_DAY_AND_MONTH

# Not equals/different operation, requires 2 parameters
  DIFF

# Greater than operation, requires 2 parameters
  GT

# Greater than or equal operation, requires 2 parameters
  GTE

# Less than operation, requires 2 parameters
  LT

# Less than or equal operation, requires 2 parameters
  LTE

# First parameter is between the following two, requires 3 parameters
  BETWEEN

# First parameter is in set of the following parameters, requires at least 2 parameters
  IN

# First parameter is not in set of the following parameters, requires at least 2 parameters
  NOT_IN

# Logical OR operation, requires conditions
  OR

# Logical AND operation, requires conditions
  AND
}

enum ConversationType {
  DIRECT_MESSAGE
  PRIVATE_GROUP
  PUBLIC_GROUP
  UNKNOWN
  USER_TO_ADMINS
}

enum DocumentStatus {
  ARCHIVED
  DECLINED
  EXPIRED

# Optix documents referencing the file attachments via `uploaded_data_id`
  MANUAL_UPLOAD
  OUT_FOR_SIGNING
  SIGNED
}

# Variable that can be evaluated based on the context
enum EvaluableVariable {
  ACCOUNT_ACTIVE_PASS_PRODUCT_ID
  ACCOUNT_ACTIVE_PLAN_ID
  ACCOUNT_ACTIVE_PLAN_TEMPLATE_ID
  ACCOUNT_CHECKIN_STATUS
  ACCOUNT_CITY
  ACCOUNT_COMPANY
  ACCOUNT_FINAL_PLAN_END_DATE
  ACCOUNT_FIRST_NAME
  ACCOUNT_ID
  ACCOUNT_LAST_BOOKING_DATE
  ACCOUNT_LAST_MOBILE_APP_USE_DATE
  ACCOUNT_MIN_DUE_INVOICE_DUE_DATE
  ACCOUNT_NEXT_ASSIGNMENT_START_DATE
  ACCOUNT_NEXT_BOOKING_DATE
  ACCOUNT_PENDING_INVOICE_DUE_DATE
  ACCOUNT_NEXT_PLAN_END_DATE
  ACCOUNT_NEXT_PLAN_START_DATE
  ACCOUNT_NEXT_TOUR_DATE
  ACCOUNT_PHONE
  ACCOUNT_POSITION
  ACCOUNT_PRIMARY_LOCATION_ID
  ACCOUNT_SHORT_BIO
  ACCOUNT_SIGNUP_DATE
  ACCOUNT_SKILLS
  ACCOUNT_SOURCE
  ACCOUNT_STATUS
  ACCOUNT_PLAN_END_DATE
  ACCOUNT_PLAN_NAME
  ACCOUNT_PLAN_PRICE
  ACCOUNT_PLAN_START_DATE
  ACCOUNT_PLAN_TEMPLATE_ID
  ACCOUNT_TOTAL_CONFIRMED_BOOKINGS
  ACCOUNT_TOTAL_INVOICES_BALANCE
  ACCOUNT_TYPE_LABEL_ID
  ACCOUNT_WALLET_ALLOWANCE_AMOUNT
  ASSIGNMENT_PRICE
  ASSIGNMENT_RESOURCE_ID
  ASSIGNMENT_RESOURCE_TYPE_ID
  ASSIGNMENT_START_DATE
  BOOKING_DATE
  BOOKING_DAY_OF_WEEK
  BOOKING_DURATION
  BOOKING_PRICE
  BOOKING_RESOURCE_ID
  BOOKING_RESOURCE_TYPE_ID
  BOOKING_SOURCE
  BOOKING_START_TIME
  DOCUMENT_NAME
  DOCUMENT_STATUS
  INVOICE_BALANCE
  INVOICE_DUE_DATE
  INVOICE_NUMBER
  INVOICE_PAID_DATE
  INVOICE_STATUS
  INVOICE_TOTAL
  ISSUE_CATEGORY

# Location inferred from a booking, checkin, sale, etc.
  LOCATION_ID
  MACRO_ASSIGNMENT_DETAILS
  MACRO_BOOKING_DETAILS
  MACRO_GET_STARTED_BUTTON
  MACRO_INVOICE_DETAILS
  MACRO_NEW_PLAN_DETAILS
  MACRO_VIEW_BOOKINGS_BUTTON
  MACRO_VIEW_INVOICE_BUTTON
  MACRO_VIEW_PLAN_BUTTON

# How many times the event happened for the enrolled account
  NTH_TIME
  ORGANIZATION_NAME
  PASS_SALE_PRODUCT_ID
  PRODUCT_SALE_PRODUCT_ID
  PRODUCT_SALE_PRODUCT_TAG
  TOUR_DATE
  TRIGGER_DATE
  WALLET_ACCESS_TEMPLATE_ID
}

enum FeatureStatus {
  DISABLED
  BASIC
  IN_TRIAL
  PLUS
}

enum MailProviderType {
  EXCHANGE
  GMAIL
  SMTP
}

enum PropertyPolicyStatus {
  HIDDEN
  OPTIONAL
  REQUIRED
}

enum WalletAccessAuditSource {
  ADMIN
  AUTOMATION
  BOOKING
  CHECKIN
  EXPIRY
  PASS
  PLAN_CYCLE_START
  PRODUCT
  UNKNOWN
}

enum WorkflowActionType {
  ADD_ALLOWANCE
  ADD_INVOICE_ITEM
  ADD_TO_GROUP_CONVERSATION
  CHANGE_ACCOUNT_TYPE
  CHANGE_PRIMARY_LOCATION
  CHANGE_USER_STATUS
  CREATE_TASK
  POST_TO_FEED
  SEND_DOC_TO_SIGN
  SEND_EMAIL
  SEND_MESSAGE
}

enum WorkflowEnrollmentStatus {
# Currently in progress
  IN_PROGRESS

# Held because action limit has been reached
  HELD

# Successfully completed
  COMPLETED

# Stopped after the automation was paused
  STOPPED

# Manually unenrolled by an admin
  UNENROLLED

# Error encountered during the execution
  ERROR
}

enum WorkflowRecipeType {
  BOOK_AGAIN
  CELEBRATE_MEMBERS_ANNIVERSARIES_LIKE_QSPACE
  CHASE_UP_INVOICES
  FEEDBACK_AFTER_X_BOOKINGS
  FIRST_DAY_OF_FIRST_PLAN
  NEW_INQUIRY
  NEW_MEMBER_CHECKIN
  NEW_TOUR_BOOKING
  OFFBOARDED
  OFFBOARDING
  ONBOARDING
  RE_ENGAGE_USERS
  STAY_ON_TOP_OF_ISSUES
  SUPPORT_MEMBERS_FIRST_BOOKING_LIKE_KWENCH
  UNCONFIRMED_USER_RETARGETING
  UPCOMING_TOUR_BOOKING
}

enum WorkflowTriggerType {
  ACCOUNT_STATUS_CHANGED
  ACCOUNT_TYPE_CHANGED
  ALLOWANCE_CONSUMED
  BOOKING_CANCELED
  BOOKING_ENDED
  CHECKIN_CANCELED
  DATE
  DOCUMENT_COMPLETE
  DOCUMENT_SENT
  INVOICE_DUE
  INVOICE_OVERDUE
  INVOICE_PAID
  INVOICE_PAYMENT_FAILED
  INVOICE_STATUS_CHANGED
  MANUAL
  NEW_ACTIVE_USER
  NEW_ASSIGNMENT
  NEW_BOOKING
  NEW_CHECKIN
  NEW_ISSUE
  NEW_PASS_SALE
  NEW_PLAN
  NEW_PRODUCT_SALE
  NEW_TOUR
  NEW_UNCONFIRMED_USER
  PLAN_STATUS_CHANGED
  SCHEDULE
  TOUR_CANCELED
}

type Query {
# Basic server information
  ping: Pong!

# Information regarding the authenticated user
  me: AuthenticatedUser!

# The number of unread messages and activities
  inboxUnread(
# Filter by organization ID
    organization_id: ID
  ): [InboxUnread!]!

# Lists all access templates associated with the current organization
  accessTemplates(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1
    order: AccessTemplateOrder = NAME_ASC
    access_template_id: [ID!]

# Filter by name
    name: String
  ): AccessTemplatePagination!
  accessTemplate(access_template_id: ID!): AccessTemplate
  accessTemplateDraft(access_template_id: ID, input: AccessTemplateInput, delete: Boolean): AccessTemplate!

# Search for one account
  account(
# Associated account
    account: AccountInput!
  ): Account!

# Lists all accounts (users and teams) associated with the current organization
  accounts(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: AccountOrder

# Search by email
    search_by_email: String

# Search by name
    search_by_name: String

# Search by name or email
    search: String

# Search by the account type (e.g. "Member" or "Team")
    type: [String!]

# Filter by account primary location
    primary_location: PrimaryLocationInput

# Filter by accounts associated to the team account
    team: AccountInput

# Filter by member ID
    member_id: [ID!]

# Filter by team ID
    team_id: [ID!]
  ): AccountPagination!
  accountInvoices(
    account: AccountInput

# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Filter by status
    status: [InvoiceStatus!]

# Finalized invoices due after the timestamp (inclusive)
    invoice_due_timestamp_from: Int

# Finalized invoices due before the timestamp (inclusive)
    invoice_due_timestamp_to: Int

# Pending invoices due after the timestamp (inclusive)
    pending_invoice_due_timestamp_from: Int

# Pending invoices due before the timestamp (inclusive)
    pending_invoice_due_timestamp_to: Int
    order: AccountInvoiceOrder = INVOICE_DUE_TIMESTAMP_DESC
  ): InvoicePagination!
  accountKPIs(account: AccountInput!): [AccountKPI]
  accountPlans(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: AccountPlanOrder

# Filter by plan ID
    account_plan_id: [ID!]

# Filter by plan template
    plan_template_id: [ID!]

# Filter by payer account
    payer_account: AccountInput

# Filter by access usage user
    access_usage_user_id: [ID!]

# Return all account plans this account has access to (admin only)
    access_usage_account: AccountInput

# Search by plan name, payer account, or access usage user
    search: String

# Filter by status
    status: [AccountPlanStatus!]

# Plans starting after the timestamp (inclusive)
    start_timestamp_from: Int

# Plans starting before the timestamp (inclusive)
    start_timestamp_to: Int

# Plans ending after the timestamp (inclusive)
    end_timestamp_from: Int

# Plans ending before the timestamp (inclusive)
    end_timestamp_to: Int

# Export the plans in CSV format
    is_export: Boolean = false

# Includes plans hidden after a failed payment
    show_hidden: Boolean = false
  ): AccountPlanPagination!
  accountPlan(account_plan_id: ID!): AccountPlan
  accountPlansDraft(
    account_plan: AccountPlanSearchInput

# Deprecated: replaced by account_plan
    account_plan_id: [ID!]
    input: AccountPlanInput

# Cancel the plan
    cancel: Boolean
    cancellation_policy: CancellationPolicyInput
  ): AccountPlansChange!
  activities(
# Search by activity title, or related accounts and attachments
    search: String

# Filter by type of entity for which activity was generated
    activity_type: [String!]

# Retrieve all new activity up to the specified last activity ID
    activity_id_from: ID

# Number of elements per page
    limit: Int = 1000

# Page
    page: Int = 1
  ): ActivityPagination!

# Lists all amenities available
  amenities(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: AmenityOrder = NAME_ASC

# Filter by amenity ID
    amenity_id: [ID!]

# Filter by amenity type
    type: [AmenityType!] = [RESOURCE]
  ): AmenityPagination!
  analyticsQuery(query: AnalyticsQueryInput!): AnalyticsQueryResponse
  analyticsEntities(entities: [AnalyticsQueryEntityInput]!): AnalyticsEntityDescription

# Lists all interactions associated with an announcement
  announcementInteractions(
# The unique ID of the announcement
    announcement_id: ID!

# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Filter by type
    type: [AnnouncementInteractionType]

# Filter by user
    user: String

# Order by
    order: AnnouncementInteractionOrder
  ): AnnouncementInteractionPagination!

# List all announcements associated with the current organization
  announcements(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: AnnouncementOrder

# Filter by location
    location_id: [ID!]

# Filter by status
    status: [AnnouncementStatus!]

# Filter by announcement title
    title: String
  ): AnnouncementPagination!

# Get one announcement
  announcement(
# Announcement ID
    announcement_id: ID!
  ): Announcement
  appLinks(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: AppLinkOrder = NAME_ASC

# Filter by app link name
    name: String

# Filter by app link position
    position: [AppLinkPosition!]

# Filter by app link visibility
    is_visible: Boolean
  ): AppLinkPagination!
  appLink(app_link_id: ID!): AppLink!

# List all assignments associated with the current organization
  assignments(
# Assignments starting after the timestamp (inclusive)
    first_occurrence_start_timestamp_from: Int

# Assignments starting before the timestamp (inclusive)
    first_occurrence_start_timestamp_to: Int

# Assignments ending after the timestamp (inclusive)
    last_occurrence_end_timestamp_from: Int

# Assignments ending before the timestamp (inclusive)
    last_occurrence_end_timestamp_to: Int

# Filter by resources
    resource: ResourceSearchInput

# Filter by status
    status: [AssignmentStatus!]

# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: AssignmentOrder
  ): AssignmentPagination!

# Get one specific assignment
  assignment(
# Assignment ID
    assignment_id: ID!
  ): Assignment
  assignmentDraft(
# ID of the assignment to update or cancel
    assignment_id: ID
    input: AssignmentInput
    payment: PaymentInput

# Cancel the assignment
    cancel: Boolean
  ): AssignmentChange!
  attachments(attachments: [AttachmentInput!], attachments_search: AttachmentSearchInput): Attachments!
  availabilityBlock(availability_block_id: ID!): AvailabilityBlock

# Lists all bookings associated with the current organization
  bookings(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: BookingOrder

# Filter by user ID (for admins only). Use -1 to retrieve data associated with all users.
    user_id: ID

# Includes new bookings
    include_new: Boolean

# Includes approved bookings
    include_approved: Boolean

# Includes completed bookings (deprecated)
    include_completed: Boolean

# Includes canceled bookings
    include_canceled: Boolean

# Includes canceled bookings (deprecated: replaced by include_canceled)
    include_cancelled: Boolean

# Includes rejected bookings
    include_rejected: Boolean

# Only associated with specific resources
    resource_id: [ID]

# Only associated with specific locations
    location_id: [ID]

# Bookings starting after the timestamp (inclusive)
    start_timestamp_from: Int

# Bookings starting before the timestamp (inclusive)
    start_timestamp_to: Int

# Bookings ending after the timestamp (inclusive)
    end_timestamp_from: Int

# Bookings ending before the timestamp (inclusive)
    end_timestamp_to: Int

# Deprecated: use start_timestamp_from
    start_from: Int

# Deprecated: use start_timestamp_to
    start_to: Int

# Includes bookings the current user was invited to
    invited: [InviteeStatus!]
    booked_as: BookingAsType
    in_progress: Boolean
    is_hidden: Boolean
    payment_calculate_mode: PaymentCalculateMode
  ): BookingPagination!

# Get booking details
  booking(
# Booking unique ID
    booking_id: ID!
  ): Booking
  bookingSet(
# Booking session ID
    booking_session_id: ID

# Booking IDs
    booking_id: [ID!]
  ): BookingSet!
  bookingsDraft(input: BookingSetInput!): BookingSet!

# Get a list of booking sources
  bookingSources: [String!]

# Get the common attribute values within a set of resources
  resourcesBulkEditDraft(
# The resources to be updated
    resource: ResourceSearchInput!
  ): ResourceBulkDraft!

# Get the common attribute values within a set of plans
  accountPlansBulkEditDraft(
# The plans to be updated
    account_plan: AccountPlanSearchInput!
  ): AccountPlanBulkDraft!

# List all calendars associated with the current organization
  calendars(types: [CalendarType!]): [Calendar!]!

# Lists all check-ins at the current organization
  checkins(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Filter by user ID (for admins only). Empty array to not filter, null for token related info.
    user_id: [ID]

# Only associated with specific locations
    location_id: [ID]

# Check-in starting after the timestamp (inclusive)
    timestamp_from: Int

# Check-in starting before the timestamp (inclusive)
    timestamp_to: Int

# Deprecated: use timestamp_from
    from: Int

# Deprecated: use timestamp_to
    to: Int
  ): CheckinPagination!

# Get check-in details
  checkin(
# Check-in unique ID
    checkin_id: ID!
  ): Checkin
  checkinDraft(checkin_id: ID, input: CheckinInput, delete: Boolean): CheckinChange!
  documents(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: DocumentOrder

# Filter the list
    search: DocumentSearchInput
  ): DocumentPagination!
  document(document_id: ID!): Document

# Preview a document for signing
  documentDraft(input: DocumentInput!): DocumentDraft!
  invoiceItems(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1
    account: [AccountInput!]
    search: String
    invoice_status: [InvoiceStatus!]

# Finalized invoices due after the timestamp (inclusive)
    invoice_due_timestamp_from: Int

# Finalized invoices due before the timestamp (inclusive)
    invoice_due_timestamp_to: Int
    order: InvoiceItemOrder = INVOICE_DUE_TIMESTAMP_DESC
    origin_type: [InvoiceItemOriginType!]
    primary_location_id: [ID!]
    pending_invoice_item_id: [ID!]

# Export the invoice items in CSV format
    is_export: Boolean = false
  ): PendingInvoiceItemPagination!

# List of available invoice tags
  invoiceTags: [Tag!]

# Invoice transactions
  transactions(
# Organization identifier
    organization_id: ID!

# Filter by location ID
    location_id: [ID!]

# Returns transactions created or canceled since this timestamp
    timestamp_from: Int

# Returns transactions created or canceled until this timestamp
    timestamp_to: Int

# Filter by transaction types
    filter_by_type: [InvoiceTransactionType]

# Filter by status
    filter_by_status: InvoiceTransactionStatus

# Filter by payment method
    filter_by_payment_method: [InvoiceTransactionPaymentMethod]

# Search by invoice number or account name
    search: String

# Order by
    order: InvoiceTransactionOrder

# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1
  ): InvoiceTransactionPagination!

# Get a list of manual payment types for transactions, by default the list of used ones
  transactionManualPaymentTypes(
# Include the payment type suggestions
    include_suggestions: Boolean = false
  ): [String!]!

# Lists all invoices associated with the current organization. Non-admin users have access to personal invoices as well as team invoices, if they are team admins.
  invoices(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: InvoiceOrder

# Filter by member ID
    member_id: ID

# Filter by team ID
    team_id: ID

# Filter by invoice ID
    invoice_id: [ID]

# Filter by tag ID (for admins only)
    tag_id: [ID!]

# Filter by tag (for admins only)
    tag: [String!]

# Includes paid invoices
    include_paid: Boolean

# Includes void invoices
    include_void: Boolean

# Includes upcoming, due, and overdue invoices
    include_upcoming: Boolean

# Filter by status
    status: [InvoiceStatus!]

# Returns invoices with due dates since this timestamp
    due_from: Int

# Returns invoices with due dates to this timestamp
    due_to: Int

# Search by account name or invoice number
    search: String
    primary_location_id: [ID!]
  ): InvoicePagination!

# Get invoice details
  invoice(
# Invoice unique ID
    invoice_id: ID!
  ): Invoice

# Return an invoice draft, considering the pending_items, new_items, and new_sales. If no items are provided, the invoice will return all pending invoice items up to the next billing date.
  invoiceDraft(
# Associated account
    account: AccountInput

# Invoice notes
    notes: String

# Due date
    due_timestamp: Int

# Pending items that should be included in this invoice
    pending_items: [PendingInvoiceItemInput]

# Expected invoicing time of the pending invoice
    expected_invoicing_timestamp: Int

# New custom items that should be created
    new_items: [InvoiceItemInput]

# New product sales that should be created
    new_sales: [InvoiceSaleInput]
  ): Invoice!

# Return a list of forecasted invoices for selected accounts
  invoiceForecasts(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Filter by account name
    name: String

# Filter by account primary location
    primary_location: PrimaryLocationInput
  ): InvoicePagination!
  issue(issue_id: ID!): Issue

# Returns an preview of refunds that will be generated when a plan subscription is canceled
  subscriptionCancelPreview(
# Member plan ID
    mp_id: ID

# Team plan ID
    op_id: ID
  ): SubscriptionCharges! @deprecated(reason: "Replaced by accountPlansDraft")

# Returns a preview of charges that will be generated when a plan subscription is updated
  subscriptionUpdatePreview(
# Member plan ID
    mp_id: ID

# Team plan ID
    op_id: ID

# UTC timestamp
    end_timestamp: Int

# Total cost of subscription
    total: Float
  ): SubscriptionCharges! @deprecated(reason: "Replaced by accountPlansDraft")

# Returns summary of plan subscription costs
  subscriptionDraft(
# Plan ID
    plan_id: ID!

# Associated account
    account: AccountInput

# Start timestamp
    start_timestamp: Int!

# End timestamp
    end_timestamp: Int

# Price modifier
    price_modifier: String

# Modified amount
    modified_amount: Float

# Setup fee
    set_up_fee: Float

# Deposit
    deposit: Float
  ): SubscriptionDraft! @deprecated(reason: "Replaced by accountPlansDraft")

# Subscription information
  subscriptionPlan(
# Member plan ID
    mp_id: ID

# Team plan ID
    op_id: ID

# Team member plan ID
    opp_id: ID
  ): PlanSubscription @deprecated

# Lists all locations associated with the current organization
  locations(
    organization_id: ID
    organization_uuid: ID

# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: LocationOrder

# Returns visible locations
    include_visible: Boolean

# Returns deleted locations
    include_deleted: Boolean

# Returns hidden locations
    include_hidden: Boolean

# Filter by location ID
    location_id: [ID!]

# Filter by location name
    name: String
  ): LocationPagination!

# Get one specific location
  location(
# Location ID
    location_id: ID!
  ): Location

# List all mail providers associated with the current organization
  mailProviders: [MailProvider!]

# Lists all members associated with the current organization
  members(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: MemberOrder

# Returns active members
    include_active: Boolean

# Returns inactive members
    include_inactive: Boolean

# Returns deleted members
    include_deleted: Boolean

# Returns lead members
    include_lead: Boolean
  ): MemberPagination! @deprecated(reason: "Use the `users` field")

# Get one member
  member(
# Select by email (mutually exclusive with `get_by_member_id` and `get_by_user_id`)
    get_by_email: String

# Select by member ID (mutually exclusive with `get_by_email` and `get_by_user_id`)
    get_by_member_id: ID

# Select by user ID (mutually exclusive with `get_by_email` and `get_by_member_id`)
    get_by_user_id: ID
  ): Member @deprecated(reason: "Use the `user` field")
  memberRemovePreview(
# Member ID
    member_id: ID!
  ): ChangeInvoice!
  conversations(
    organization_id: ID

# Last received `conversation_sequence_up_to`, to be used with `order=CONVERSATION_SEQUENCE_ASC`. Prohibits `conversation_sequence_up_to`
    conversation_sequence_from: ID

# Last received `conversation_sequence_from`, to be used with `order=LATEST_MESSAGE_DESC`. Prohibits `conversation_sequence_from`
    conversation_sequence_up_to: ID

# Desired limit of conversations (default: 1000, max: 5000). The limit may be exceeded if multiple conversations have the same sequence number.
    limit: Int

# Order by
    order: ConversationOrder = CONVERSATION_SEQUENCE_ASC

# Filter conversations by type
    conversation_type: [ConversationType!]

# Include conversations even if you are not a participant (PUBLIC_GROUP for everyone, USER_TO_ADMINS for admins only)
    include_joinable: [ConversationType!]

# Exclude conversations where you are a participant
    exclude_joined: [ConversationType!]

# Filter conversations by specific account
    account_id: ID

# Search by group name, user name or email, and message content
    search: String
  ): ConversationsUpdate!
  conversation(
    organization_id: ID
    conversation_id: ID!

# Last received `message_sequence_up_to`, or 0 to fetch all starting from the oldest
    message_sequence_from: ID

# Desired limit of messages (default: 200, max: 1000). The limit may be exceeded if multiple messages have the same sequence number.
    limit: Int

# Filter by thread
    attached_message_id: ID

# Mark all retrieved messages as read (deprecated: use conversationRead)
    mark_as_read: Boolean = false
  ): ConversationUpdate!
  conversationItems(
    conversation_id: ID!

# Filter by thread
    attached_message_id: ID

# Items created after the timestamp (inclusive)
    created_timestamp_from: Int

# Items created before the timestamp (inclusive)
    created_timestamp_to: Int

# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: ConversationItemOrder = CREATED_TIMESTAMP_DESC
  ): ConversationItemPagination!
  conversationUserSuggestions(
# Search by name or email
    search: String

# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Includes lead, inactive, and deleted users (for admins only)
    include_forbidden_to_message: Boolean = false

# Whether to include both users and admins or just admins (for admins only)
    include_admins_only: Boolean = false
  ): UserProfilePagination!

# Check mobile app compatibility
  mobileAppCheck(user_id: ID, auth_token: String, member_id: ID, location_id: ID, organization_id: ID, device_id: String, app_platform: MobileAppPlatform, app_version: String, app_package_name: String, os_version: String): MobileAppCheckResponse!
  note(
# Note unique ID
    note_id: ID!
  ): Note
  notificationSettings: [NotificationSettings!]!

# Optix billing details
  optixBilling: OptixBilling

# Whether the product has been purchased before
  optixBillingPurchased(product: String!): Boolean!

# Validate tiers and pre-select the lowest valid tier
  optixSignupDraft: [OptixBillingPlan!]!
  organization(subdomain: String, organization_uuid: String): Organization

# Organizations accepting the onboarding of new users
  onboardableOrganizations(
    longitude: String!
    latitude: String!

# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1
  ): OrganizationPagination!

# Retrieve a list of payment methods available for setup and their respective links
  retainablePaymentMethods(organization_id: ID, organization_uuid: ID, account: AccountInput): [RetainablePaymentMethodOption!]!
  stripePaymentMethods(organization_id: ID, organization_uuid: ID, search_after: ID): StripePaymentMethodsPagination
  planTemplates(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Filter by plan template name
    name: String

# Filter by the availability for new users
    onboarding_enabled: Boolean

# Filter by the availability for the existing users
    non_onboarding_enabled: Boolean
    user_visibility: [UserVisibility!]

# Filter by location
    location_id: [ID!]

# Filter by the provided access
    access: AccessSearchInput
  ): PlanTemplatePagination!
  planTemplate(plan_template_id: ID!): PlanTemplate

# Lists all product collections associated with the current organization
  productCollections(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Filter by location
    location_id: [ID!]

# Filter by collection name
    name: String

# Filter by visibility (for admins only)
    is_public: Boolean

# Filter by product type
    type: [ProductType!] = [REGULAR]

# Order by
    order: ProductCollectionOrder
  ): ProductCollectionPagination!

# Get one specific product collection
  productCollection(
# Product collection ID
    product_collection_id: ID!

# Filter products by location
    location_id: [ID!]
  ): ProductCollection

# Lists all product sales associated with the current organization
  productSales(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Filter by location
    location_id: [ID!]

# Filter by product name
    product_name: String

# Filter by product tag
    product_tags: [String!]

# Filter by label
    label_id: [ID!]

# Filter by account
    account_id: ID

# Filter by access usage user (for passes)
    access_usage_account: AccountInput

# Filter by account name
    account_name: String

# Search by account name or product name
    search: String

# Filter by invoice status
    invoice_status: [InvoiceStatus!]

# Sales generated after the timestamp (inclusive)
    created_timestamp_from: Int

# Sales generated before the timestamp (inclusive)
    created_timestamp_to: Int

# Includes canceled sales
    include_canceled: Boolean

# Order by
    order: ProductSaleOrder = NUMBER_DESC

# Product type
    type: [ProductType!] = [REGULAR]

# Filter by passes with allowance left
    has_allowance_left: Boolean
  ): ProductSalePagination!

# Get one specific product collection
  productSale(
# Product sale ID
    product_sale_id: ID!
  ): ProductSale
  productSaleDraft(product_sale_id: ID, input: ProductSaleInput!): ProductSaleChange!

# List all products associated with the current organization
  products(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Filter by product name
    name: String

# Filter by location
    location_id: [ID!]

# Filter by label
    label_id: [ID!]

# Filter by tag
    tags: [String!]

# Filter by the availability for new users
    onboarding_enabled: Boolean

# Filter by the availability for the existing users
    non_onboarding_enabled: Boolean
    user_visibility: [UserVisibility!]

# Filter by type
    type: [ProductType!] = [REGULAR]

# Filter by the provided access (for passes)
    access: AccessSearchInput

# Order by
    order: ProductOrder
  ): ProductPagination!

# Get one specific product
  product(
# Product ID
    product_id: ID!
  ): Product
  productTags: [String!]! @deprecated(reason: "Replaced by Organization.tags")
  properties(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: PropertyOrder = PREDEFINED_ORDER
  ): PropertyPagination!
  property(property_id: ID!): Property!
  propertyGroups: [PropertyGroup!]!

# Get a public profile of a user
  userProfile(
# Select by user ID (mutually exclusive with `member_id`)
    user_id: ID

# Select by member ID (mutually exclusive with `user_id`)
    member_id: ID
  ): UserProfile

# Get a public profile of a team
  teamProfile(
# Select by team ID
    team_id: ID!
  ): TeamProfile

# Draft a recurrence to get the generated description and rules
  recurrenceDraft(input: RecurrenceDraftInput!): Recurrence!
  resourceTypeGroups(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: ResourceTypeGroupOrder = NAME_ASC

# Filter by resource type group IDs
    resource_type_group_id: [ID!]

# Filter by resource type IDs
    resource_type_id: [ID!]

# Filter by resource type group name
    name: String
  ): ResourceTypeGroupPagination!

# Get one specific resource type group
  resourceTypeGroup(
# Resource type group ID
    resource_type_group_id: ID!
  ): ResourceTypeGroup
  resourceTypes(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: ResourceTypeOrder = NAME_ASC

# Filter by resource type IDs
    resource_type_id: [ID!]

# Filter by resource type name
    name: String

# Filter by booking experience
    booking_experience: [BookingExperience!]
  ): ResourceTypePagination!

# Get one specific resource type
  resourceType(
# Resource type ID
    resource_type_id: ID!
  ): ResourceType

# Lists all resources associated with the current organization
  resources(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: ResourceOrder

# Filter by resource ID
    resource_id: [ID!]

# Filter by location ID
    location_id: [ID!]

# Returns bookable/non-bookable only. Null for both.
    is_bookable: Boolean

# Whether this resource can be booked by admins only.
    is_bookable_by_admins_only: Boolean

# Whether this resource can be assigned. Null for both.
    is_assignable: Boolean

# Filter by resource name
    name: String

# Filter the resources that are connected to external calendars (e.g. Google, Exchange)
    include_connected_to_calendars: Boolean

# Deprecated: use name
    title: String

# Filter by resource types
    resource_type_id: [ID!]

# Filter by resource type groups
    resource_type_group_id: [ID!]

# Filter by minimum capacity
    capacity_from: Int
  ): ResourcePagination!

# Get one specific resource
  resource(
# Resource ID
    resource_id: ID!
  ): Resource
  resourceAvailability(
# Resource search parameters
    input: ResourceAvailabilityInput!
    exclude_booking_id: ID

# Number of resources
    limit: Int

# Order by
    order: ResourceAvailabilityOrder = LOCATION_RATING_DESC
  ): [ResourceAvailability!]!
  resourceAvailabilityGroups(
# Resource search parameters
    input: ResourceAvailabilityInput!

# Ignore the booked time interval
    exclude_booking_id: Int

# Filter the groups by the number of available resources
    quantity: Int

# Filter the groups by the number of available resources
    quantity_from: Int

# Filter the groups by the number of available resources
    quantity_to: Int

# Deprecated: replaced by quantity
    group_capacity: Int

# Deprecated: replaced by quantity_from
    group_capacity_from: Int

# Deprecated: replaced by quantity_to
    group_capacity_to: Int

# Number of resource groups
    limit: Int

# Number of resources within each group
    group_limit: Int

# Order by
    order: ResourceAvailabilityOrder = LOCATION_RATING_DESC
  ): [ResourceAvailabilityGroup!]!
  schedule(
# Filter by event type
    type: [ScheduleEventType!]

# Events starting after the timestamp (inclusive)
    start_timestamp_from: Int

# Events starting before the timestamp (inclusive)
    start_timestamp_to: Int

# Events ending after the timestamp (inclusive)
    end_timestamp_from: Int

# Events ending before the timestamp (inclusive)
    end_timestamp_to: Int

# Filter by resources
    resource: ResourceSearchInput

# Filter by locations
    location_id: [ID!]

# Filter by owner accounts
    owner_account_id: [ID!]

# Filter by payer accounts
    payer_account_id: [ID!]

# Filter by status
    status: [ScheduleEventStatus!]

# Search by user, team, or resource name, booking ID, assignment ID
    search: String

# Deprecated
    plan_id: [ID!]

# Filter by source
    source: [String!]

# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: ScheduleEventOrder
  ): ScheduleEventPagination!
  scheduleConflicts(
# Location ID
    location_id: [ID!]

# Resource ID
    resource_id: [ID!]

# Start timestamp
    start_timestamp: Int

# End timestamp
    end_timestamp: Int

# Start datetime in the location timezone
    start_datetime: DateTime

# End datetime in the location timezone
    end_datetime: DateTime

# Recurrence rule for repeat bookings or assignments
    recurrence: RecurrenceInput

# Ignore the assigned time intervals
    exclude_assignment_id: ID

# Ignore the blocked time intervals
    exclude_availability_block_id: ID

# Ignore the booked time interval
    exclude_booking_id: ID
  ): ScheduleConflicts!
  tasks(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: TaskOrder

# Filter the list
    search: TaskSearchInput
  ): TaskPagination!
  task(task_id: ID!): Task
  teams(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: TeamOrder
  ): TeamPagination!
  teamRemovePreview(
# Team ID
    team_id: ID!
  ): ChangeInvoice!

# Lists all tours associated with the current organization
  tours(
# Number of elements per page
    limit: Int = 100

# Page (default: 1)
    page: Int

# Only associated with specific locations
    location_id: [ID!]
  ): TourPagination!

# Get one specific tour
  tour(
# Tour ID
    tour_id: ID!
  ): Tour

# List all users associated with the current organization
  users(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: UserOrder

# Returns active users
    include_active: Boolean

# Returns inactive users
    include_inactive: Boolean

# Returns deleted users
    include_deleted: Boolean

# Returns pending users
    include_pending: Boolean

# Search by email
    search_by_email: String

# Search by name
    search_by_name: String

# Search by name or email
    search: String
  ): UserPagination!

# Get one user
  user(
# Select by email (mutually exclusive with `get_by_member_id` and `get_by_user_id`)
    get_by_email: String

# Select by member ID (mutually exclusive with `get_by_email` and `get_by_user_id`)
    get_by_member_id: ID

# Select by user ID (mutually exclusive with `get_by_email` and `get_by_member_id`)
    get_by_user_id: ID
  ): User

# Get a list of user sources, by default the list of used ones
  userSources(
# Include Optix suggested sources
    include_suggestions: Boolean = false
  ): [String!]
  userPasswordStrength(password: String!): UserPasswordStrength!
  userSignupDraft(
# Source of the user
    source: String = "User app"
    plan: PlanSignupInput
    product: ProductSaleInput

# Type of payment method; controls the transaction fee
    payment_method_type: String
  ): UserSignupSummary!

# List of users and respective accesses
  userWalletAccessTemplates(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1
    search_by_email: String
  ): UserAccessPagination!
  accountWallets(
    account: AccountInput
    allowance_timestamp: Int

# Include all accessible wallets, specifically team wallets
    include_shared_wallets: Boolean = true

# Include all previous and future accesses
    include_all_access_templates: Boolean = false
  ): [Wallet!]!
  walletAccessAudit(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1
    wallet_id: ID!
    access_template_id: ID!

# Filter the list
    search: WalletAccessAuditSearchInput
  ): WalletAccessAuditPagination!

# List all automations associated with the current organization
  workflows(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: WorkflowOrder

# Filter the list
    search: WorkflowSearchInput
  ): WorkflowPagination!

# Get one specific automation
  workflow(workflow_id: ID!): Workflow

# List all available steps for automations
  workflowAvailableSteps: [WorkflowStep!]!

# List the automation enrollments
  workflowEnrollments(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: WorkflowEnrollmentOrder

# Filter the list
    search: WorkflowEnrollmentSearchInput
  ): WorkflowEnrollmentPagination!

# List the recommended automation recipes
  workflowRecipes(recipe_type: [WorkflowRecipeType!]): [WorkflowRecipe!]!
  workflowEmailDraft(input: WorkflowActionEmailInput!, trigger_type: WorkflowTriggerType!): WorkflowEmailDraft!
  workflowDocDraft(input: WorkflowActionDocToSignInput!, trigger_type: WorkflowTriggerType!): DocumentDraft!
}

type Mutation {
# Ping with the specific timezone. This mutation exists for testing purposes :)
  pingTimezone(
# Time zone in TZDATA format (e.g. "America/Vancouver")
    timezone: String = "UTC"
  ): Pong!
  accessTemplateCommit(access_template_id: ID, input: AccessTemplateInput, delete: Boolean): AccessTemplate!
  accountUpdate(account: [AccountInput!]!, set_no_primary_location: Boolean, primary_location_id: ID): [Account!]! @deprecated(reason: "Replaced by accountsCommit")
  accountsCommit(account: [AccountInput!]!, input: AccountDetailsInput!): BulkMutationResponse!
  adminAccountPanelSettingsCommit(input: AdminAccountPanelSettingsInput!): AdminAccountPanelSettings!
  accountPlansCommit(
    account_plan: AccountPlanSearchInput

# Deprecated: replaced by account_plan
    account_plan_id: [ID!]
    input: AccountPlanInput

# Cancel the plan
    cancel: Boolean
    cancellation_policy: CancellationPolicyInput
  ): BulkMutationResponse!
  activityUpdate(activity_id: [ID!]!, is_read: Boolean!): [Activity!]!

# Create a new amenity
  amenityCreate(input: AmenityInput!): Amenity!

# Update the existing amenity
  amenityUpdate(
# Amenity ID
    amenity_id: ID!
    input: AmenityInput!
  ): Amenity!

# Delete the existing amenity
  amenityDelete(
# Amenity ID
    amenity_id: ID!
  ): Amenity!

# Creates a new announcement interaction
  announcementInteractionCreate(
# Announcement ID
    announcement_id: ID!

# User ID
    user_id: ID!

# Type of interaction
    interaction_type: AnnouncementInteractionType!
  ): AnnouncementInteraction!

# Creates a new announcement
  announcementCreate(
# Announcement title
    title: String!

# Announcement description
    description: String!

# Announcement image
    image: FileUpload

# Buttons displayed with the announcement
    buttons_type: AnnouncementButtons!

# Call to action button text when buttons_type is SINGLE
    button_text: String

# Announcement schedule options
    schedule: AnnouncementScheduleInput!

# Whether the announcement is paused
    is_paused: Boolean!

# Locations in which the announcement will be visible
    location_id: [ID!]
  ): Announcement!

# Updates existing announcement
  announcementUpdate(
# Announcement ID
    announcement_id: [ID!]!

# Announcement title
    title: String

# Announcement description
    description: String

# Announcement image
    image: FileUpload

# Buttons displayed with the announcement
    buttons_type: AnnouncementButtons

# Call to action button text when buttons_type is SINGLE
    button_text: String

# Announcement schedule options
    schedule: AnnouncementScheduleInput

# Whether the announcement is paused
    is_paused: Boolean!

# Locations in which the announcement will be visible
    location_id: [ID!]
  ): [Announcement!]!

# Deletes existing announcements
  announcementsDelete(
# Announcement ID to delete
    announcement_id: [ID]!
  ): [Announcement!]!

# Create a new app link
  appLinkCreate(
# App link name
    name: String!

# App link icon
    icon: String!

# App link position
    position: AppLinkPosition!

# Whether the app link is visible
    is_visible: Boolean = true

# App link target url
    url: String

# Resource types
    resource_type_id: [ID!]
  ): AppLink!

# Update the existing app links
  appLinksUpdate(
# App link ID
    app_link_id: [ID!]!

# App link name
    name: String

# App link icon
    icon: String

# App link position
    position: AppLinkPosition

# Whether the app link is visible
    is_visible: Boolean

# App link target url
    url: String

# Resource types
    resource_type_id: [ID!]
  ): BulkMutationResponse!

# Delete the existing app links
  appLinksDelete(
# App link ID
    app_link_id: [ID!]!
  ): BulkMutationResponse!
  assignmentCommit(
# ID of the assignment to update or cancel
    assignment_id: ID
    input: AssignmentInput
    payment: PaymentInput

# Cancel the assignment
    cancel: Boolean
  ): AssignmentChange!
  availabilityBlockCommit(availability_block_id: ID, input: AvailabilityBlockInput, delete: Boolean): AvailabilityBlock!
  bookingsCommit(input: BookingSetInput!): BookingSet!
  bookingSetInviteeStatus(booking_id: ID!, user_id: ID!, status: InviteeStatus!): Booking!

# Connect or disconnect the calendars
  calendarsCommit(input: [CalendarsInput!]!): BulkMutationResponse!

# Delete the stored calendar provider credentials
  calendarProviderDisconnect(
# Calendar provider
    provider: CalendarProvider!
  ): CalendarProviderCredentials!
  checkinCommit(checkin_id: ID, input: CheckinInput, delete: Boolean): CheckinChange!

# Send a document for signing
  documentCommit(input: DocumentInput!): Document!

# Resend the document to those who haven't signed it yet
  documentResend(document_id: ID!): [String!]!
  documentArchive(document_id: ID!): Document!
  eventTrack(event: String!): EventTrackResponse
  featureSettingsUpdate(input: FeatureSettingsInput!): FeatureSettings!

# Pre-upload a file for faster one-time usage in other mutations (e.g. create a resource with an image)
  fileUpload(
# Base64 file content
    base64_content: String!

# Intended file usage
    usage: FileUsage!

# Original file name (for usage=ATTACHMENTS or DOCS_TO_SIGN)
    name: String

# If false, keep a file to be used directly as a file attachment
    is_preupload: Boolean = true
  ): FileData
  pendingInvoiceItemCreate(
    member_id: ID
    team_id: ID
    organization_id: ID

# Invoice item details
    details: InvoiceItemInput

# Deprecated: replaced by details
    charge: InvoiceItemInput!

# Expected invoicing time of the pending invoice
    expected_invoicing_timestamp: Int
  ): PendingInvoiceItem!
  pendingInvoiceItemUpdate(
    pending_invoice_item_id: ID!

# Invoice item details
    details: InvoiceItemInput

# Deprecated: replaced by details
    charge: InvoiceItemInput!
  ): PendingInvoiceItem!

# Create a custom invoice item
  invoiceItemCreate(
    invoice_id: ID!

# Invoice item details
    details: InvoiceItemInput

# Deprecated: replaced by details
    charge: InvoiceItemInput!
  ): InvoiceItem!

# Update the custom invoice item
  invoiceItemUpdate(
    item_id: ID!

# Invoice item details
    details: InvoiceItemInput

# Deprecated: replaced by details
    charge: InvoiceItemInput!
  ): InvoiceItem!

# Delete the custom item from the invoice
  invoiceItemDelete(
# ID of the pending invoice item
    pending_invoice_item_id: ID

# ID of the invoice item
    item_id: ID
  ): InvoiceItem!

# Move the item to a new void invoice
  invoiceItemVoid(
# ID of the pending invoice item
    pending_invoice_item_id: ID

# ID of the invoice item
    item_id: ID
  ): Invoice!

# Creates a new invoice tag
  invoiceTagCreate(
# Invoice ID
    invoice_id: ID!

# Tag name
    tag_name: String!

# Tag color
    color: TagColor!
  ): InvoiceTag!

# Updates an existing invoice tag
  invoiceTagUpdate(
# Tag ID
    tag_id: ID!

# Tag name
    tag_name: String!

# Color
    color: TagColor!
  ): InvoiceTag!

# Deletes an existing invoice tag
  invoiceTagDelete(
# Tag ID
    tag_id: ID!
  ): InvoiceTag!

# Creates a new invoice transaction
  invoiceTransactionCreate(
# Invoice ID
    invoice_id: ID!

# Transaction description
    description: String

# Deprecated: replaced by description
    note: String!

# Transaction type
    type: InvoiceTransactionType = NOTE

# Amount associated with this transaction. The type NOTE does not accept an amount.
    amount: Float

# Type of a manual payment (e.g. "ACH direct deposit", "Cash", etc.)
    manual_payment_type: String
  ): InvoiceTransaction!

# Removes payments, refunds, and credit applications
  invoiceTransactionRemove(
# Invoice ID
    invoice_id: ID!

# Transaction ID
    transaction_id: [ID!]!
  ): Invoice!

# Create new invoice with items specified by `pending_items`, `new_items`, and `new_sales`. If no items provided, it will include all pending invoice items due on a given day (by default, the next billing day)
  invoiceCreate(
# Associated account
    account: AccountInput

# Invoice notes
    notes: String

# Due date
    due_timestamp: Int

# Original expected invoicing time of the pending items
    expected_invoicing_timestamp: Int

# Pending items that should be included in this invoice
    pending_items: [PendingInvoiceItemInput]

# New custom items that should be created
    new_items: [InvoiceItemInput]

# New product sales that should be created
    new_sales: [InvoiceSaleInput]
  ): Invoice!

# Bulk create new invoices with items specified by `new_items` and `new_sales`
  invoicesCreate(
# Associated accounts
    accounts: [AccountInput]

# Due date
    due_timestamp: Int

# Original expected invoicing time of the pending items
    expected_invoicing_timestamp: Int

# Use primary account location
    use_account_primary_location: Boolean = false

# New custom items that should be created
    new_items: [InvoiceItemInput]

# New product sales that should be created
    new_sales: [InvoiceSaleInput]
  ): [Invoice]!

# Set invoice number
  invoiceSetNumber(
# Invoice ID
    invoice_id: ID!

# Invoice number
    number: String!
  ): Invoice!

# Void invoice
  invoiceVoid(
# Invoice ID
    invoice_id: ID!
  ): Invoice!

# Void multiple invoices
  invoicesVoid(
# IDs of invoices to void (max 500)
    invoice_id: [ID!]!
  ): BulkMutationResponse!

# Unvoid invoice
  invoiceUnvoid(
# Invoice ID
    invoice_id: ID!
  ): Invoice!

# Marks as paid
  invoiceSetPaid(
# Invoice ID
    invoice_id: ID!

# Type of a manual payment (e.g. "ACH direct deposit", "Cash", etc.)
    manual_payment_type: String
  ): Invoice!

# Marks pending invoice as paid
  invoiceDraftSetPaid(
# Account
    account: AccountInput!

# Expected invoicing time of the pending invoice
    expected_invoicing_timestamp: Int

# Type of a manual payment (e.g. "ACH direct deposit", "Cash", etc.)
    manual_payment_type: String
  ): Invoice!

# Pay an invoice
  invoicePay(
# Invoice ID
    invoice_id: ID!

# Optional payment method
    pm_id: ID
  ): Invoice!

# Pay multiple invoices
  invoicesPay(
# IDs of invoices to pay
    invoice_id: [ID!]!
  ): BulkMutationResponse!

# Pay a pending invoice
  invoiceDraftPay(
# Account
    account: AccountInput!

# Expected invoicing time of the pending invoice
    expected_invoicing_timestamp: Int

# Optional payment method
    pm_id: ID
  ): Invoice!

# Void a pending invoice
  invoiceDraftVoid(
# Account
    account: AccountInput!

# Expected invoicing time of the pending invoice
    expected_invoicing_timestamp: Int

# Pending items that should be included in this invoice
    pending_items: [PendingInvoiceItemInput]
  ): Invoice!

# Adds notes to an invoice
  invoiceSetNotes(
# Invoice ID
    invoice_id: ID!

# Notes
    notes: String!
  ): Invoice!

# Sends an invoice
  invoiceSend(
# Invoice ID
    invoice_id: ID!

# Email (default: user email for personal invoices, and a team admin email for team invoices)
    email: String
  ): Invoice!

# Creates an invoice with the booking charge
  bookingChargeNow(
# Booking unique ID
    booking_id: ID!
  ): Invoice!

# Creates an invoice for member subscription
  subscriptionChargeNow(
# Member plan unique ID
    mp_id: ID

# Team plan unique ID
    op_id: ID
  ): [Invoice]! @deprecated(reason: "Replaced by accountPlansCommit")

# Allocates the credit from the available credit notes to unpaid invoices within the same account
  invoiceApplyCredit(amounts: [CreditTransactionInput!]!): [Invoice!]!

# Set invoice due date
  invoiceSetDueDate(
# Invoice ID
    invoice_id: ID!

# Invoice due timestamp
    due_timestamp: Int!
  ): Invoice!

# Enable or disable auto/manual payment
  invoiceTogglePayment(
# Invoice ID
    invoice_id: ID!

# Indicates whether this invoice has disabled auto/manual payments
    has_disabled_payments: Boolean!
  ): Invoice!

# Use location billing address as "From"
  invoiceSetLocation(
# Invoice ID
    invoice_id: ID!

# Location ID
    location_id: ID!
  ): Invoice!
  invoiceRecalculateTransactionFee(
# Invoice ID
    invoice_id: ID!

# Desired payment method type
    payment_method_type: String

# Transaction fee won't be auto-recalculated if set to true
    override_transaction_fee: Boolean! = false
  ): Invoice!

# Create a new label
  labelCreate(
# Label name
    name: String!

# Object type
    object_type: LabelType!

# Label color
    color: LabelColor!
  ): Label!

# Update the existing label
  labelUpdate(
# Label ID
    label_id: ID!

# Label name
    name: String

# Color
    color: LabelColor
  ): Label!

# Delete the existing labels
  labelsDelete(
# Label ID
    label_id: [ID!]!

# Replacement label ID
    replacement_label_id: ID
  ): BulkMutationResponse!
  locationCommit(location_id: ID, input: LocationInput!): Location!

# Commit mail provider
  mailProviderCommit(input: MailProviderInput, mail_provider_id: ID, delete: Boolean = false, replacement_mail_provider_id: ID): MailProvider!

# Removes a member from an organization. Creates an invoice with any pending charges
  memberRemove(
# Member ID
    member_id: [ID!]!

# Collect payment (add all pending charges to an invoice which is due today)
    collect_payment: Boolean = true
  ): [Member!]!

# Send a message
  messageCreate(
# Direct message recipients (mutually exclusive with `conversation_id`)
    target: MessageTargetInput

# Conversation (mutually exclusive with `target`)
    conversation_id: ID

# Location this message is related to (for conversation_type=USER_TO_ADMINS)
    location_id: ID

# HTML content of a message
    message: String

# Message attachments
    attachments: [AttachmentInput!]

# Deprecated: recipients will choose how to receive the notifications
    force_email_notification: Boolean = false
    from: MessageFromInput
  ): BulkMutationResponse!

# React to a message
  messageReact(message_id: ID!, reactions: [String!]!): ConversationMessage!

# Delete a message
  messageDelete(message_id: ID!): ConversationMessage!

# Create or update a group conversation
  conversationCommit(conversation_id: ID, input: ConversationInput!): ConversationUpdate!

# Join a group conversation
  conversationJoin(conversation_id: ID!, target: MessageTargetInput): Boolean!

# Leave a group conversation
  conversationLeave(conversation_id: ID!): Boolean!

# Mark a conversation as read
  conversationRead(conversation_id: ID!, message_sequence_up_to: ID!): BulkMutationResponse
  mobileAppSettingsUpdate(status: MobileAppStatus, design: MobileAppDesignSettingsInput, authorization: MobileAppAuthorizationSettingsInput, notification_phone: String): MobileAppSettings!
  noteCommit(note_id: ID, input: NoteInput, delete: Boolean): Note!
  notificationSettingsUpdate(input: [NotificationSettingsInput!]!): BulkMutationResponse!
  notificationCreate(
    target: MessageTargetInput!
    title: String
    message: String!
    payload: JsonString
    type: String!

# Deprecated: recipients will choose how to receive this notification based on its type
    channels: [NotificationChannel!]
  ): BulkMutationResponse!

# Purchase Optix add-on
  optixBillingPurchase(product: String!): OptixBillingAudit!

# Request a plan upgrade
  optixBillingUpgrade(product: String!): OptixBillingAudit!
  organizationUpdate(input: OrganizationInput!): Organization!

# Create new terms version for organization
  organizationTermsCreate(terms: String!): Organization!
  organizationPaymentGatewayUpdate(
# Organization ID
    organization_id: ID!
    enabled_checkout_methods: [String!]
    retainable_payment_methods: [String!]
  ): OrganizationPaymentGateway
  stripePaymentMethodsImport(organization_id: ID, organization_uuid: ID, payment_methods: [StripePaymentMethodImportInput!]!): [StripePaymentMethodImported!]!
  paymentMethodDelete(
# Payment method
    payment_method_id: ID!
  ): PaymentMethod!

# Move a payment method from a user to a team
  paymentMethodTransfer(
# Payment method
    payment_method_id: ID!

# New owner account
    account: AccountInput!
  ): PaymentMethod!
  planTemplateCommit(plan_template_id: ID, input: PlanTemplateInput, delete: Boolean): PlanTemplate!

# Creates a new product collection
  productCollectionCreate(
# Collection name
    name: String!

# Collection description
    description: String!

# Collection image
    image: FileUpload

# Indicates whether the collection is public
    is_public: Boolean!

# Indicates whether the collection is visible on the mobile app homescreen
    is_on_app: Boolean!

# The rule for including the products by tags
    include_tags_rule: IncludeProductTagsRule = ANY

# Whether the collection is available in all locations
    in_all_locations: Boolean = true

# Product type
    type: ProductType = REGULAR

# Locations in which the collection will be visible
    location_id: [ID!]

# Tags used to include the products
    include_tags: [String!]

# Tags used to group the included products
    group_tags: [String!]
  ): ProductCollection!

# Updates existing product collections
  productCollectionsUpdate(
# Collection ID
    product_collection_id: [ID!]!

# Collection name
    name: String

# Collection description
    description: String

# Collection image
    image: FileUpload

# Indicates whether the collection is public
    is_public: Boolean

# Indicates whether the collection is visible on the mobile app homescreen
    is_on_app: Boolean

# Include product tags rule
    include_tags_rule: IncludeProductTagsRule

# Whether the collection is available in all locations
    in_all_locations: Boolean = true

# Product type
    type: ProductType

# Locations in which the collection will be visible
    location_id: [ID!]

# Tags used to include the products
    include_tags: [String!]

# Tags used to group the included products
    group_tags: [String!]
  ): [ProductCollection!]!

# Deletes existing collections
  productCollectionsDelete(
# Collection IDs to delete
    product_collection_id: [ID!]!
  ): [ProductCollection!]!
  productSaleCommit(product_sale_id: ID, input: ProductSaleInput!): ProductSale!

# Creates a new sale
  saleCreate(
# Product ID
    product_id: ID!

# Associated account
    account: AccountInput!

# Location ID
    location_id: ID

# Add the charge to the invoice (only for admins)
    invoice_id: ID

# Expected invoicing time of the pending invoice (only for admins)
    expected_invoicing_timestamp: Int

# Invoice item name (for admins only)
    name: String

# Invoice item description (for admins only)
    description: String

# Number of products
    quantity: Float = 1

# Invoice item quantity
    invoice_item_quantity: Float = 1

# Unit amount (for admins only)
    unit_amount: Float

# Exclusive tax rate (e.g. 5 for 5%, max: 99.9999, for admins only)
    tax_rate: Float

# Inclusive tax rate (e.g. 5 for 5%, max: 99.9999, for admins only)
    inclusive_tax_rate: Float

# Notes
    notes: String

# Sale labels (for admins only)
    label_id: [ID!]
  ): ProductSale! @deprecated(reason: "Replaced by productSaleCommit")

# Create a new product
  productCreate(
# Product name
    name: String!

# Product description
    description: String!

# Terms (for passes)
    terms: String

# Product image (for regular products)
    image: FileUpload

# Appearance (for passes)
    appearance: String

# Indicates whether the product is available for new users
    onboarding_enabled: Boolean = true

# Indicates whether the product is available for the existing users
    non_onboarding_enabled: Boolean = true

# Indicates whether the product should be promoted
    promote: Boolean = false

# Deprecated: replaced by prices
    unit_amount: Float

# Price list
    prices: [PriceInput!]

# Override the default invoicing settings
    override_tax_rate: Boolean = false

# Exclusive tax rate (e.g. 5 for 5%, max: 99.9999)
    tax_rate: Float

# Override the default invoicing settings
    override_inclusive_tax_rate: Boolean = false

# Inclusive tax rate (e.g. 5 for 5%, max: 99.9999)
    inclusive_tax_rate: Float

# Product type
    type: ProductType = REGULAR

# Accesses (for passes)
    accesses: [AccessInput!]

# Expiration time (for passes)
    allowance_expire_days: Int

# Whether the product is available in all locations
    in_all_locations: Boolean = true

# Locations where the product is available
    location_id: [ID!]

# Product labels
    label_id: [ID!]

# Product tags
    tags: [String!]
  ): Product!

# Update the existing products
  productsUpdate(
# Product ID
    product_id: [ID!]!

# Product name
    name: String

# Product description
    description: String

# Terms (for passes)
    terms: String

# Product image (for regular products)
    image: FileUpload

# Appearance (for passes)
    appearance: String

# Indicates whether the product is available for new users
    onboarding_enabled: Boolean = true

# Indicates whether the product is available for the existing users
    non_onboarding_enabled: Boolean = true

# Indicates whether the product should be promoted
    promote: Boolean

# Deprecated: replaced by prices
    unit_amount: Float

# Price list
    prices: [PriceInput!]

# Override the default invoicing settings
    override_tax_rate: Boolean

# Exclusive tax rate (e.g. 5 for 5%, max: 99.9999)
    tax_rate: Float

# Override the default invoicing settings
    override_inclusive_tax_rate: Boolean

# Inclusive tax rate (e.g. 5 for 5%, max: 99.9999)
    inclusive_tax_rate: Float

# Accesses (for passes)
    accesses: [AccessInput!]

# Expiration time (for passes)
    allowance_expire_days: Int

# Whether the product is available in all locations
    in_all_locations: Boolean = true

# Locations where the product is available
    location_id: [ID!]

# Product labels
    label_id: [ID!]

# Product tags
    tags: [String!]
  ): [Product!]!

# Delete the existing products
  productsDelete(
# Product ID
    product_id: [ID!]!
  ): [Product!]!
  propertyValuesCommit(
# A list of users (for admins only)
    account: [AccountInput!]

# Property values
    properties: [PropertyValueInput!]!
  ): BulkMutationResponse!
  propertyGroupCreate(input: PropertyGroupInput!): PropertyGroup!
  propertyGroupUpdate(property_group_id: ID!, input: PropertyGroupInput!): PropertyGroup!
  propertyGroupDelete(property_group_id: ID!): PropertyGroup!
  propertyCreate(input: PropertyInput!): Property!
  propertyUpdate(property_id: ID!, input: PropertyInput!): Property!
  propertyDelete(property_id: ID!): Property!

# Create a new resource type group
  resourceTypeGroupCreate(input: ResourceTypeGroupInput!): ResourceTypeGroup!

# Update the existing resource type group
  resourceTypeGroupUpdate(
# Resource type group ID
    resource_type_group_id: ID!
    input: ResourceTypeGroupInput!
  ): ResourceTypeGroup!

# Delete the existing resource type group
  resourceTypeGroupDelete(
# Resource type group ID
    resource_type_group_id: ID!
  ): ResourceTypeGroup!

# Create a new resource type
  resourceTypeCreate(input: ResourceTypeInput!): ResourceType!

# Update the existing resource type
  resourceTypeUpdate(
# Resource type ID
    resource_type_id: ID!
    input: ResourceTypeInput!
  ): ResourceType!

# Delete the existing resource type
  resourceTypeDelete(
# Resource type ID
    resource_type_id: ID!

# Move remaining resources to another type
    move_to_resource_type_id: ID

# Delete resources within this resource type instead of moving them to another type
    delete_resources: Boolean = false
  ): ResourceType!

# Create a new resource
  resourceCreate(input: ResourceInput!, quantity: Int = 1): Resource!

# Update the existing resource
  resourceUpdate(
# Resource ID
    resource_id: ID!
    input: ResourceInput!
  ): Resource!

# Delete the existing resource
  resourceDelete(
# Resource ID
    resource_id: ID!
  ): Resource!

# Update the existing resources
  resourcesUpdate(
# The resources to be updated
    resource: ResourceSearchInput!
    input: ResourceInput!
  ): BulkMutationResponse!

# Delete the existing resources
  resourcesDelete(
# The resources to be deleted
    resource: ResourceSearchInput!
  ): BulkMutationResponse!

# Duplicate the existing resources
  resourceDuplicate(
# Resource ID
    resource_id: ID!

# How many duplicates to create
    count: Int!

# Custom names
    names: [String!]!

# Add a number after the resource name
    append_numbers_to_names: Boolean = false

# Begin numbering at
    append_numbers_from: Int = 1
  ): BulkMutationResponse!

# Creates a new organization tag
  tagCreate(
# Tag
    tag: String!
  ): Tag!
  tasksCommit(task: TaskSearchInput, input: TaskInput): BulkMutationResponse!

# Create a new team
  teamCreate(
# Team name
    name: String
    users: [AccountInput!]!
    admins: [AccountInput!]!
  ): Team!

# Remove a team from an organization. Creates an invoice with any pending charges
  teamRemove(
# Team ID
    team_id: ID!

# Collect payment (add all pending charges to an invoice which is due today)
    collect_payment: Boolean = true
  ): Team!
  tourCreate(
    organization_id: ID!
    location_id: ID!
    name: String
    surname: String
    email: String!
    phone: String
    company: String
    avatar: FileUpload
    primary_location_id: ID
    title: String
    description: String
    skills: [String!]
    city: String
    linkedin: String
    start_timestamp: Int!
    end_timestamp: Int

# Property values
    properties: [PropertyValueInput!]
    recaptcha: RecaptchaInput!
  ): Tour!
  tourCancel(tour_id: ID!): Tour!

# Create a new user. An already existing email may trigger the reactivation of the user at the organization
  userCreate(
# User name; ignored if the email belongs an existing user
    name: String

# User surname; ignored if the email belongs to an existing user
    surname: String

# User email
    email: String!

# User password, which you will NOT be able to change later; ignored for existing users
    password: String

# Deprecated
    notify_user_by_email: Boolean = false
    billing_tax_number: String
    billing_address: String
    billing_postcode: String
    billing_city: String
    billing_region: String
    billing_country: String

# Additional email for billing purposes
    billing_email: String

# Phone number
    phone: String

# Source of the user
    source: String

# Primary location
    primary_location_id: ID

# Whether to add a lead or an active user
    is_lead: Boolean = false
  ): User!
  userDeletionRequest(organization_id: ID!): User!
  userSignupCommit(
# Source of the user
    source: String = "User app"
    plan: PlanSignupInput
    product: ProductSaleInput
  ): UserSignupSummary!
  walletAccessAdd(
    wallet_id: ID!
    access_template_id: ID!
    access_usage_user_id: ID
    unlimited_allowance: Boolean
    allowance: Float
    allowance_unit_id: ID
    allowance_expire_days: Int

# The charge for the allowance being added to the wallet
    invoice_item: InvoiceItemInput
    expected_invoicing_timestamp: Int
  ): AvailableWalletAccess!
  walletAccessUpdate(wallet_id: ID!, access_template_id: ID!, access_usage_user_id: ID, discount_pct: Float, unlimited_allowance: Boolean, allowances: [AvailableAllowanceInput!]): AvailableWalletAccess
  walletAccessExpire(wallet_id: ID!, access_template_id: ID!, access_usage_user_id: ID): BulkMutationResponse!
  workflowsCommit(workflow: WorkflowSearchInput, input: WorkflowInput, delete: Boolean = false): BulkMutationResponse!
  workflowUnenroll(workflow_enrollment_id: ID!): WorkflowEnrollment!

# Enroll a manual automation
  workflowEnroll(workflow_id: ID!, account_id: [ID!], account_plan: AccountPlanSearchInput): BulkMutationResponse!
  workflowEnrollmentRetry(workflow_enrollment: WorkflowEnrollmentSearchInput): BulkMutationResponse!

# Send a test email to the current user's address using dummy user and data
  workflowEmailSendTest(input: WorkflowActionEmailInput!, trigger_type: WorkflowTriggerType!): String!

# Send a test document for signing
  workflowDocSendTest(input: WorkflowActionDocToSignInput!, trigger_type: WorkflowTriggerType!): String!
  workflowVersionRollback(workflow_version_id: ID!): Workflow!
}

scalar JsonString

# A datetime string in 'Y-m-d H:i:s' format.
scalar DateTime

# A time string in `hh:mm:ss` format.
scalar Time

# Day of the week
enum WeekDay {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum TimeUnit {
  SECOND
  MINUTE
  HOUR
  DAY
  WEEK
  MONTH
}

type Duration {
  value: Int!
  unit: TimeUnit!
}

input DurationInput {
  value: Int!
  unit: TimeUnit!
}

enum ObjectType {
  ACCOUNT
  ACCOUNT_PLAN
  ASSIGNMENT
  BOOKING
  CHECKIN
  CONVERSATION
  DOCUMENT
  FEED_POST
  FEED_POST_COMMENT
  FILE
  INVOICE
  ISSUE
  LOCATION
  MEMBER
  MESSAGE
  NOTE
  ORGANIZATION
  PLAN_TEMPLATE
  PRODUCT
  PRODUCT_COLLECTION
  RESOURCE
  RESOURCE_TYPE
  SALE
  TASK
  TEAM
  TOUR
  USER
  WORKFLOW
  UNKNOWN
}

type InboxUnread {
  organization_id: ID!
  activities: Int!
  conversations: Int!
}

# Pong is the response to ping ;)
type Pong {
# Current status of the service
  status: String!

# Current timestamp
  time: Int!

# Current time for humans
  localtime: String!

# Current version
  version: String

# Current version tag
  tag: String
}

type BulkMutationResponse {
# Amount of entities affected
  total: Int!

# IDs of entities effected (account plans only)
  id: [ID!]
}

input RecaptchaInput {
  token: String!
  package_name: String
}

type AccessTemplate {
  access_template_id: ID!
  name: String!
  type: AccessTemplateType!
  is_editable: Boolean!
  in_use: Boolean!
  rules: AccessTemplateRules!
  location_count: Int!
  resource_count: Int!
  product_count: Int!
}

input AccessTemplateInput {
  name: String
  rules: AccessTemplateRulesInput
}

enum AccessTemplateType {
  CHECKINS
  CUSTOM
  DELETED_PLAN_ACCESS @deprecated
  EVERYTHING
  PRODUCT_COLLECTION
  RESOURCE_TYPE
  RESOURCES
  UNKNOWN
}

type AccessTemplateRules {
  location_id: [ID!]
  all_resources: Boolean
  resource_id: [ID!]
  resource_type_id: [ID!]
  all_products: Boolean
  product_id: [ID!]
  product_collection_id: [ID!]
  checkins: Boolean
}

input AccessTemplateRulesInput {
  location_id: [ID!]
  all_resources: Boolean
  resource_id: [ID!]
  resource_type_id: [ID!]
  all_products: Boolean
  product_id: [ID!]
  product_collection_id: [ID!]
  checkins: Boolean
}

type AccessTemplatePagination {
# The number of available elements
  total: Int!

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of access templates
  data: [AccessTemplate!]!
}

# Order of the access templates
enum AccessTemplateOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC
}

type Access {
  access_id: ID!
  access_template: AccessTemplate
  unlimited_allowance: Boolean
  allowance: Float
  unit: Unit
  discount_pct: Float
  description: String!
  short_description: String! @deprecated
}

input AccessInput {
  access_id: ID
  access_template_id: ID
  unlimited_allowance: Boolean
  allowance: Float
  unit_id: ID
  discount_pct: Float
}

# Search for plan templates or passes that include the specified items
input AccessSearchInput {
# Filter by access template
  access_template_id: [ID!]

# Filter the access templates by location
  location_id: [ID!]

# Filter the access templates by resource
  resource_id: [ID!]

# Filter the access templates by product
  product_id: [ID!]

# Filter the access templates by the ability to check in
  checkins: Boolean

# Whether the allowance is included
  allowance: Boolean
}

# A billing account
type Account {
# The account ID
  account_id: ID!

# The wallet ID
  wallet_id: ID

# The account name
  name: String!
  email: String
  phone: String
  source: String
  company: String

# Job title
  title: String

# Professional headline
  profession: String

# User-defined professional headline
  industry: String

# Biography
  description: String
  skills: [String!]

# City
  city: String

# Country
  country: String

# Twitter
  twitter: String

# Website
  website: String
  linkedin: String
  additional_notification_emails: [String]
  require_payment_method: Boolean
  enable_autopayments: String
  is_checked_in: Boolean
  child_accounts: [Account!]
  parent_accounts: [Account!]
  admin_accounts: [Account!]

# Type of the account (e.g. lead, member, team)
  type_label: Label!

# The account type (e.g. "Member" or "Team")
  type: String!

# Timestamp when the account will be invoiced next
  next_invoicing_timestamp: Int

# Legacy user unique ID
  user_id: ID @deprecated(reason: "Consider using account_id to refer to the billing data")

# Legacy member unique ID
  member_id: ID @deprecated(reason: "Consider using user_id to refer to this user, and account_id to refer to the billing data")

# Team unique ID
  team_id: ID @deprecated(reason: "Consider using account_id to refer to this account")

# Email address used for billing purposes
  billing_email: String @deprecated(reason: "Consider using billing_details")
  primary_location: Location
  image: String @deprecated(reason: "Replaced by avatar")
  billing_details: InvoiceBillingDetails
  payment_methods: [PaymentMethod!]
  avatar: FileData

# All plan subscriptions
  plan_subscriptions(include_active: Boolean = true, include_inactive: Boolean): [PlanSubscription]! @deprecated

# Notes (for admins only)
  notes: [Note!]
  tasks(limit: Int = 10, page: Int = 1, order: TaskOrder = CREATED_TIMESTAMP_DESC): TaskPagination!

# Automation enrollments (for admins only)
  enrollments(limit: Int = 10, page: Int = 1, order: WorkflowEnrollmentOrder = CREATED_TIMESTAMP_DESC): WorkflowEnrollmentPagination!

# Conversations (for admins only)
  conversations(
    limit: Int = 10

# Int max is set by default to get most recent conversations
    conversation_sequence_up_to: ID = 9223372036854775807
    order: ConversationOrder = LATEST_MESSAGE_DESC
  ): ConversationsUpdate!

# Files (for admins only)
  files: [FileData!]
  status: AccountStatus!
  created_timestamp: Int
  current_terms_agreement: OrganizationTermsAgreement
  latest_mobile_version: String
}

input AccountDetailsInput {
# Set no primary location
  set_no_primary_location: Boolean

# Primary location
  primary_location_id: ID

# Account status (ACTIVE, INACTIVE, or COMMUNITY; for users)
  status: AccountStatus

# Deprecated: replaced by enable_autopayments
  auto_payments: Boolean

# Whether invoices get paid automatically using the account's default payment method
  enable_autopayments: Boolean

# Type of the account (e.g. lead, member, team)
  type_label_id: ID
  require_payment_method: Boolean
  billing_details: InvoiceBillingDetailsInput
  name: String
  email: String
  phone: String

# Account source (e.g. "Web onboarding"; for users)
  source: String
  company: String

# Job title
  title: String

# Professional headline
  profession: String

# Industry
  industry: String

# Biography
  description: String
  skills: [String!]

# City
  city: String

# Country
  country: String

# Twitter
  twitter: String

# Website
  website: String

# Linkedin
  linkedin: String
  additional_notification_emails: [String!]
  avatar: FileUpload
  child_account_id: [ID!]
  admin_account_id: [ID!]
  uploaded_data_id: [ID!]
}

# Provide one of the following: (account_id), (member_id), (organization_id, user_id), (organization_id, team_id)
input AccountInput {
# Account ID
  account_id: ID

# Member ID
  member_id: ID

# Organization ID
  organization_id: ID

# User ID. You should also specify an organization_id
  user_id: ID

# Team ID. You should also specify an organization_id
  team_id: ID
}

# Account pagination wrapper
type AccountPagination {
# The number of available elements
  total: Int!

# List of accounts
  data: [Account!]!
}

# Order of the users
enum AccountOrder {
# Sorts ASC name
  NAME_ASC

# Sorts DESC name
  NAME_DESC

# Sorts ASC created
  CREATED_ASC

# Sorts DESC created
  CREATED_DESC
}

enum AccountInvoiceOrder {
# Sorts due ASC
  INVOICE_DUE_TIMESTAMP_ASC

# Sorts due DESC
  INVOICE_DUE_TIMESTAMP_DESC
}

type AdminAccountPanelSettings {
  kpi_widget: [AccountPaneWidgetSettings!]
  left_widget: [AccountPaneWidgetSettings!]
  middle_widget: [AccountPaneWidgetSettings!]
  right_widget: [AccountPaneWidgetSettings!]
}

input AdminAccountPanelSettingsInput {
  kpi_widget: [AccountPanelWidgetSettingsInput!]
  left_widget: [AccountPanelWidgetSettingsInput!]
  middle_widget: [AccountPanelWidgetSettingsInput!]
  right_widget: [AccountPanelWidgetSettingsInput!]
}

type AccountPaneWidgetSettings {
  name: String!
  order: Int!
  enabled: Boolean!
  is_open: Boolean!
  is_hidden: Boolean!
}

input AccountPanelWidgetSettingsInput {
  name: String!
  order: Int!
  enabled: Boolean!
  is_open: Boolean!
}

type AccountKPI {
  value: String!
  name: AccountWidget!
}

type OrganizationTermsAgreement {
  terms: OrganizationTerms!
  version: Int!
  timestamp: Int!
  ip: String!
}

type AccountPlanPagination {
  total: Int!

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")
  data: [AccountPlan!]!
  export_csv: String
}

type AccountPlan {
  account_plan_id: ID!
  payer_account: Account
  access_usage_user: User
  plan_template: PlanTemplate

# Included items
  accesses: [Access!]!
  name: String!
  terms: String
  price: Float
  price_frequency: PlanFrequency!
  deposit: Float
  deposit_refund: Float
  set_up_fee: Float

# Override the default invoicing settings
  override_tax_rate: Boolean!

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float

# Override the default invoicing settings
  override_inclusive_tax_rate: Boolean!

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float
  start_timestamp: Int!
  end_timestamp: Int
  status: AccountPlanStatus!
  canceled_timestamp: Int
  created_timestamp: Int!

# Free trial length
  free_trial_days: Int

# Start billing cycle
  anchor_start_timestamp: Int!

# Invoice deposit, setup fee, and any prorated charges
  initial_invoice_due_timestamp: Int!
  invoiced_up_to_timestamp: Int
  new_price_effective_timestamp: Int!
  next_invoice_timestamp: Int
  allowance_renewal_frequency: PlanFrequency!
  allowance_renewed_up_to_timestamp: Int
  new_accesses_effective_timestamp: Int!
  next_allowance_renewal_timestamp: Int
}

input AccountPlanInput {
  payer_account: [AccountInput!]
  access_usage_user_id: ID
  plan_template_id: ID

# Included items
  accesses: [AccessInput!]

# New items to include, keeping the others
  add_accesses: [AccessInput!]

# Items to remove, keeping the others
  remove_accesses: [AccessInput!]
  name: String
  terms: String
  price: Float
  price_frequency: PlanFrequency
  deposit: Float
  set_up_fee: Float

# Override the default invoicing settings
  override_tax_rate: Boolean

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float

# Override the default invoicing settings
  override_inclusive_tax_rate: Boolean

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float
  start_timestamp: Int
  end_timestamp: Int
  no_end: Boolean

# Free trial length
  free_trial_days: Int

# Start billing cycle
  anchor_start_timestamp: Int

# Invoice deposit, setup fee, and any prorated charges
  initial_invoice_due_timestamp: Int
  allowance_renewal_frequency: PlanFrequency
}

input PlanSignupInput {
  payer_account: AccountInput
  access_usage_user_id: ID
  plan_template_id: ID!
  start_timestamp: Int!
  end_timestamp: Int
  no_end: Boolean
}

input AccountPlanSearchInput {
  account_plan_id: [ID!]
  plan_template_id: [ID!]
  payer_account: AccountInput
  access_usage_user_id: [ID!]
  access_usage_account: AccountInput
  search: String
  status: [AccountPlanStatus!]
  start_timestamp_from: Int
  start_timestamp_to: Int
  end_timestamp_from: Int
  end_timestamp_to: Int
}

type AccountPlansChange {
  account_plans: [AccountPlan!]!
  invoices: [ChangeInvoice!]!
}

enum AccountPlanStatus {
  ACTIVE
  CANCELED
  ENDED
  IN_TRIAL
  UPCOMING
  UNKNOWN
}

# Order of the plans
enum AccountPlanOrder {
  PAYER_ACCOUNT_NAME_ASC
  PAYER_ACCOUNT_NAME_DESC
  NAME_ASC
  NAME_DESC
  PRICE_ASC
  PRICE_DESC
  STATUS_ASC
  STATUS_DESC
  START_TIMESTAMP_ASC
  START_TIMESTAMP_DESC
  END_TIMESTAMP_ASC
  END_TIMESTAMP_DESC
}

type ActivityPagination {
# The number of available elements
  total: Int!

# List of activities
  data: [Activity!]!
}

type Activity {
  activity_id: ID!
  title: String!
  is_read: Boolean!
  actor_object_id: ID
  actor_object_type: String
  actor_name: String
  actor_icon_url: String
  created_by_user_id: ID @deprecated(reason: "Will be removed")
  created_by_user_name: String @deprecated(reason: "Will be removed")
  notification_type: String!
  attachments: [ActivityAttachment!]
  created_timestamp: Int!
  updated_timestamp: Int!
}

type ActivityAttachment {
  object_id: ID!
  object_type: ObjectType!
  title: String!
  subtitle: String
  icon_url: String
  created_timestamp: Int!
  updated_timestamp: Int!
}

# Amenity pagination wrapper
type AmenityPagination {
# The number of available elements
  total: Int!

# List of amenities
  data: [Amenity!]!
}

type Amenity {
# Amenity ID
  amenity_id: ID!

# Name (e.g. "Wi-Fi", "Whiteboard", etc.)
  name: String!
  description: String! @deprecated(reason: "Discontinued")

# Icon image URL
  image: String @deprecated(reason: "Image support will be removed")

# Amenity type
  type: AmenityType!

# Whether the amenity is editable or not
  is_editable: Boolean!
}

input AmenityInput {
  name: String
  type: AmenityType
}

# Order of the amenities
enum AmenityOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC
}

enum AmenityType {
  LOCATION
  RESOURCE
}

type AnalyticsQueryResponse {
# Organization currency code (e.g. CAD)
  currency: String

# Organization currency symbol
  currency_symbol: String

# Organization default timezone
  timezone: String

# Organization default locale
  locale: String

# Latest update of the analytics data
  last_update_timestamp: Int

# Page
  page: Int

# Number of items/limit in this page
  per_page: Int

# Total of lines considering all pages
  total: Int

# Column description
  columns: [AnalyticsResponseField]

# Tabular data response, the order of the data and the column is the same as mentioned at the fields request
  data: [[String]]
}

type AnalyticsEntityDescription {
  relationships: [AnalyticsEntityRelationship]
  fields: [AnalyticsResponseField]
}

type AnalyticsEntityRelationship {
  from: String!

# Name of the relationship
  name: String!
  description: String
  to: [AnalyticsEntityName]!
}

type AnalyticsResponseField {
  name: String!
  title: String!
  type: AnalyticsResponseColumnType!
  description: String
}

input AnalyticsQueryInput {
  entities: [AnalyticsQueryEntityInput]
  fields: [AnalyticsQueryFieldInput]
  conditions: [AnalyticsQueryConditionInput]

# List of fields to order by (e.g. REVENUE.total:DESC)
  order_by: [AnalyticsQueryOrder]
  page: Int
  per_page: Int
}

input AnalyticsQueryEntityInput {
  entity: AnalyticsEntityName!
  relationship: AnalyticsQueryEntityRelationshipInput
  alias: String
}

input AnalyticsQueryOrder {
  field: String!

# Ascending or descending order
  asc: Boolean = true

# Default fields instead of null
  if_null_fields: [String!]

# Default value instead of null
  if_null_value: String
  if_null_type: AnalyticsResponseColumnType = STRING
}

input AnalyticsQueryEntityRelationshipInput {
# Name of the relationship, use analyticsEntities to figure out what are the available relationship names
  name: String!

# Optional relationship aliases, use this to refer to a specific entity name/alias
  to: [String]
}

input AnalyticsQueryConditionInput {
# Operation name (e.g EQUALS)
  operation: AnalyticsQueryConditionOperationInput

# Parameters are used for conditions like EQUALS, DIFF and GT, check AnalyticsQueryConditionOperationInput for more information
  parameters: [AnalyticsQueryConditionValueInput]

# Parameters are used for conditions like AND, OR and NOT, check AnalyticsQueryConditionOperationInput for more information
  conditions: [AnalyticsQueryConditionInput]
}

input AnalyticsQueryFieldInput {
# Name of the field, should always be ENTITY.field_name, you can use analyticsEntities query to figure the fields available
  name: String!

# Aggregation mode (e.g. SUM)
  aggregate: AnalyticsAggregateType

# Defines the order of aggregation FIRST or LAST. You cannot order by fields being grouped by
  aggregate_order_by: [AnalyticsQueryOrder!]

# Group by this field, useful when you are aggregating other fields
  group_by: Boolean = false

# Optional title replacement
  title: String

# Alias for this field, useful if you want to reuse the same field multiple times for different aggregations
  alias: String

# Default fields instead of null
  if_null_fields: [String!]

# Default value instead of null
  if_null_value: String
  if_null_type: AnalyticsResponseColumnType = STRING
}

input AnalyticsQueryConditionValueInput {
# Describe an entity field (e.g. REVENUE.total)
  field: String

# Describe a value, this field will be automatically casted based on the first parameter provided at the condition
  value: String

# Default fields instead of null
  if_null_fields: [String!]

# Default value instead of null
  if_null_value: String
  if_null_type: AnalyticsResponseColumnType = STRING
}

enum AnalyticsQueryConditionOperationInput {
# Equals operation, requires 2 parameters
  EQUALS

# Not equals/different operation, requires 2 parameters
  DIFF

# Greater than operation, requires 2 parameters
  GT

# Greater than or equal operation, requires 2 parameters
  GTE

# Less than operation, requires 2 parameters
  LT

# Less than or equal operation, requires 2 parameters
  LTE

# First parameter is between the following two, requires 3 parameters
  BETWEEN

# First parameter is in set of the following parameters, requires at least 2 parameters
  IN

# First parameter is not in set of the following parameters, requires at least 2 parameters
  NOT_IN

# Logical OR operation, requires conditions
  OR

# Logical AND operation, requires conditions
  AND

# Logical NOT operation, requires conditions
  NOT

# True when the first parameter is null
  IS_NULL

# True when the first parameter is not null
  IS_NOT_NULL
}

enum AnalyticsAggregateType {
# Average
  AVG

# Sum
  SUM

# Count number of occurrences, use SUM for summing up the values
  COUNT

# List separated by commas
  GROUP_CONCAT

# Minimum value
  MIN

# Maximum value
  MAX

# Standard deviation
  STD

# Variance
  VARIANCE

# Return any value from the aggregation. Useful when aggregating a field that has no relevance while grouping other columns
  ANY_VALUE

# Return the last value of the series, you should provide the argument aggregate_order_by otherwise the behavior is the same as MAX
  LAST

# Return the first value of the series, you should provide the argument aggregate_order_by otherwise the behaviur is the same as MIN
  FIRST
}

enum AnalyticsEntityName {
# Users and teams
  ACCOUNT

# Statistics of the accounts along the time, including number of accounts per status and type
  ACCOUNT_DAILY_STATS

# Statistics of the accounts along the time, including number of accounts per status and type
  ACCOUNT_DAILY_STATS_PER_LOCATION

# Account periods represents a location period of an account
  ACCOUNT_LOCATION_PERIOD
  ACCOUNT_PLAN

# Daily account plan statistics, grouped by the primary locations of payer accounts and plan templates
  ACCOUNT_PLAN_DAILY_STATS

# Account periods representing a status period of an account
  ACCOUNT_STATUS_PERIOD

# Account plan periods representing a status period of a plan
  ACCOUNT_PLAN_STATUS_PERIOD
  ASSIGNMENT
  BOOKING
  CHECKIN
  INVOICE
  INVOICE_TRANSACTION
  LOCATION
  PLAN @deprecated(reason: "Replaced by PLAN_TEMPLATE")
  PLAN_TEMPLATE
  PRODUCT
  RESOURCE

# Statistics of the resources along the time, including usage time and number of bookings
  RESOURCE_DAILY_STATS
  REVENUE
  SUBSCRIPTION @deprecated(reason: "Replaced by ACCOUNT_PLAN")
  TEAM_ASSOCIATION
}

enum AnalyticsResponseColumnType {
  BOOLEAN
  DATE
  DATETIME
  FLOAT
  INTEGER
  JSON
  STRING
  TIMESTAMP
}

# A community announcement interaction
type AnnouncementInteraction {
# The interaction ID
  announcement_interaction_id: ID!

# The announcement ID
  announcement_id: ID!

# The user associated with this interaction
  user: User

# Timestamp when the announcement was seen
  seen: Int

# Timestamp when the announcement was clicked
  clicked: Int

# Timestamp when the announcement was accepted
  accepted: Int

# Timestamp when the announcement was declined
  declined: Int

# Status of the interaction
  status: AnnouncementInteractionStatus!

# Last updated timestamp
  updated_timestamp: Int!
}

# Announcement interaction types
enum AnnouncementInteractionType {
# Announcement has been seen
  SEEN

# Announcement button has been clicked
  CLICKED

# Announcement 'accept' button has been clicked
  ACCEPTED

# Announcement 'decline' button has been clicked
  DECLINED
}

enum AnnouncementInteractionStatus {
# Announcement has been seen
  SEEN

# Announcement button has been clicked
  CLICKED

# Announcement 'accept' button has been clicked
  ACCEPTED

# Announcement 'decline' button has been clicked
  DECLINED
}

# Announcement pagination wrapper
type AnnouncementInteractionPagination {
# The number of available elements
  total: Int!

# List of announcement interactions
  data: [AnnouncementInteraction]!
}

# Order of the announcement interactions
enum AnnouncementInteractionOrder {
# Sort by seen date ASC
  SEEN_ASC

# Sort by seen date DESC
  SEEN_DESC

# Sort by clicked date ASC
  CLICKED_ASC

# Sort by clicked date DESC
  CLICKED_DESC

# Sort by user name ASC
  USER_ASC

# Sort by user name DESC
  USER_DESC
}

# A community announcement
type Announcement {
# The announcement ID
  announcement_id: ID!

# The announcement title
  title: String!

# The announcement description
  description: String!

# Announcement image
  image: FileData

# Buttons displayed with the announcement
  buttons_type: AnnouncementButtons!

# Call to action button text when buttons_type is SINGLE
  button_text: String

# Scheduled start time for the announcement
  start_timestamp: Int!

# Scheduled end time for the announcement
  end_timestamp: Int!

# Times the announcement should repeat
  repeat: AnnouncementRepeatOptions

# Status of the announcement
  status: AnnouncementStatus!

# Amount of times the announcement has been seen
  seen: Int

# Amount of times the announcement has been clicked
  clicked: Int

# Amount of times the announcement has been accepeted
  accepted: Int

# Amount of times the announcement has been declined
  declined: Int

# Locations associated with this announcement
  locations: [Location!]!

# Whether the announcement is paused
  is_paused: Boolean

# Whether the announcement is set to start immediately
  schedule_start_now: Boolean

# Whether the announcement is set to never stop
  schedule_stop_never: Boolean
}

# Announcement repeat options
enum AnnouncementRepeatOptions {
# Does not repeat
  NO_REPEAT

# Repeats daily
  DAY

# Repeats weekly
  WEEK

# Repeats monthly
  MONTH
}

# Announcement status
enum AnnouncementStatus {
# The announcement is currently visible
  LIVE

# Scheduled to show up in the future
  SCHEDULED

# The announcement has expired
  ENDED

# The announcement has been paused
  PAUSED
  UNKNOWN
}

# Schedule options for an announcement
input AnnouncementScheduleInput {
# Indicates if the announcement should start immediately
  start_now: Boolean

# Scheduled date for when the announcement should start
  start_timestamp: Int

# Expiration date of the announcement
  end_timestamp: Int

# Indicates if the announcement should never stop
  stop_never: Boolean

# Times the announcement should repeat
  repeat: AnnouncementRepeatOptions!
}

# Announcement buttons
enum AnnouncementButtons {
# Single button
  SINGLE

# Accept and decline buttons
  ACCEPT_DECLINE

# No buttons
  NO_BUTTONS
}

# Order of the announcements
enum AnnouncementOrder {
# Order by title ASC
  TITLE_ASC

# Order by title DESC
  TITLE_DESC

# Order by seen count ASC
  SEEN_ASC

# Order by seen count DESC
  SEEN_DESC

# Order by clicked count ASC
  CLICKED_ASC

# Order by clicked count DESC
  CLICKED_DESC

# Order by accepted count ASC
  ACCEPTED_ASC

# Order by accepted count DESC
  ACCEPTED_DESC

# Order by declined count ASC
  DECLINED_ASC

# Order by declined count DESC
  DECLINED_DESC

# Order by status ASC
  STATUS_ASC

# Order by status DESC
  STATUS_DESC

# Sort by creation date ASC
  CREATED_TIMESTAMP_ASC

# Sort by creation date DESC
  CREATED_TIMESTAMP_DESC
}

# Announcement pagination wrapper
type AnnouncementPagination {
# The number of available elements
  total: Int!

# If nothing found, try without the location filter applied
  found_in_all_locations: Boolean!
  total_in_all_locations: Int! @deprecated(reason: "Replaced by found_in_all_locations")

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of announcements
  data: [Announcement]!
}

# App link pagination wrapper
type AppLinkPagination {
# The number of available elements
  total: Int!

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of app links
  data: [AppLink!]!
}

type AppLink {
# App link unique ID
  app_link_id: ID!

# App link name
  name: String!

# App link icon
  icon: String

# Whether the app link is visible
  is_visible: Boolean!

# App link position
  position: AppLinkPosition!

# App link target url
  url: String

# Resource types
  resource_types: [ResourceType!]!

# Date created
  created_timestamp: Int!
}

enum AppLinkPosition {
# Primary position in mobile home screen
  MOBILE_HOME_PRIMARY

# More screen item
  MOBILE_MORE_SCREEN
}

# Order of the app links
enum AppLinkOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC

# Sort by URL ASC
  URL_ASC

# Sort by URL DESC
  URL_DESC

# Sort by visibility ASC
  IS_VISIBLE_ASC

# Sort by visibility DESC
  IS_VISIBLE_DESC
}

# App information
input AppInput {
# App name (e.g. "My printer app")
  name: String

# Configuration settings for canvases and webhooks
  configuration: String

# Category of this app
  category: String

# Short description (max length: 100)
  short_description: String

# Long description
  full_description: String

# External link to the vendor
  external_link: String

# Logo used at app listing
  logo: FileUpload
}

# Describe an app created by you or any third-party
type App {
# The client ID of this app
  client_id: String!

# The app name
  name: String!

# The secret ID of this app (will be redacted for third-party users)
  secret_id: String

# Advanced configuration options (will be redacted for third-party users)
  configuration: String

# Category of this app
  category: String

# Short description (max length: 100)
  short_description: String

# Long description
  full_description: String

# External link to the vendor
  external_link: String

# A link to the help page
  faq_link: String

# Logo used at app listing
  logo: FileData

# Creation timestamp
  created_timestamp: Int!

# Last update timestamp
  updated_timestamp: Int!

# Current app status
  status: AppStatus!

# Current publication status. The app can be used by other organizations when published
  public: Boolean!

# List of webhooks associated with this app (will be redacted for third-party users)
  webhooks: [AppWebhook]

# Pricing details for a paid app
  price: AppPrice
}

# An app webhook
type AppWebhook {
# The name of the event that triggered this webhook
  event: String!

# The target for this webhook
  url: String!
}

# An installable app
type AppInstallable {
# App basic data
  app: App!

# True if the app is currently installed in the organization
  installed: Boolean

# If the app with a free trial is installed, it indicates when a trial ends
  free_trial_end_timestamp: Int
}

# Collection of authentication data associated with one app
type AppAuthentication {
# App information
  app: App!

# Organization token. Can be redacted for non-administrative members.
  organization_token: String

# Personal token. Its associated with the logged in user. Can be undefined if you are using an organization token to fetch this data.
  personal_token: String
}

# Canvas description
type AppCanvas {
# App associated with this canvas
  app: App!

# Personal token associated with this canvas
  personal_token: String

# Position for this canvas
  type: String!

# Identification is the unique name for this canvas at this organization
  identification: String!

# URL is the target address for this canvas
  url: String!

# Primary title
  title: String

# Primary subtitle
  subtitle: String

# Secondary title
  secondary_title: String

# Secondary URL (target address for the secondary title)
  secondary_url: String

# Icon name (based on a predefined list)
  icon: String

# Icon URL
  icon_url: String

# Defines if the canvas header is locked or not
  lock_header: Boolean

# Defines if the canvas will show mobile native loading spinner
  native_loading: Boolean

# Defines if the canvas will open using the native browser
  native_browser: Boolean

# Max height for this canvas
  height: Int

# Priority (lower number means higher priority)
  priority: Int!

# Minimum required admin role for the dashboard canvases
  admin_role: AdminRole

# Whether to show the canvas before the other ones
  show_at_top: Boolean

# Define whether the Optix variables should not be included at the url
  include_context_variables: Boolean

# Parent menu item
  menu_parent: String
}

# App status
enum AppStatus {
# Active app
  ACTIVE

# Deleted app
  DELETED
}

type Assignment {
# Assignment unique ID
  assignment_id: ID!

# The assigned resource
  resource: Resource!
  owner_account: Account!
  payer_account: Account!

# Frequency of the repeat payments (MONTHLY, YEARLY)
  price_frequency: RecurrenceFrequency

# Interval of the repeat payments (e.g. given MONTHLY frequency, 2 for "every other month")
  price_interval: Int

# Assignment price
  price: Float

# Assignment deposit
  deposit_amount: Float

# Assignment setup fee
  setup_fee: Float

# Override the default invoicing settings
  override_tax_rate: Boolean!

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float

# Override the default invoicing settings
  override_inclusive_tax_rate: Boolean!

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float

# Credit back any unused assignment charges
  credit_unused_time: Boolean

# Return the deposit
  credit_deposit_amount: Float
  first_occurrence_start_timestamp: Int!
  last_occurrence_end_timestamp: Int
  duration_sec: Int!
  recurrence: Recurrence!

# Assignment notes
  notes: String

# Assignment status
  status: AssignmentStatus!
  invoices: [Invoice!]!
  invoiced_up_to_timestamp: Int

# Creation date
  created_timestamp: Int!

# The user who created this assignment
  created_by_user: User!
}

enum AssignmentStatus {
  UPCOMING
  ACTIVE
  ENDED
  CANCELED
}

# Assignment pagination wrapper
type AssignmentPagination {
# The number of available elements
  total: Int!

# If nothing found, try without the location filter applied
  found_in_all_locations: Boolean!
  total_in_all_locations: Int! @deprecated(reason: "Replaced by found_in_all_locations")

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of assignments
  data: [Assignment!]!
}

enum AssignmentOrder {
# Sort by price ASC
  PRICE_ASC

# Sort by price DESC
  PRICE_DESC

# Sort by creation date ASC
  CREATED_TIMESTAMP_ASC

# Sort by creation date DESC
  CREATED_TIMESTAMP_DESC

# Sort by start timestamp of the first occurrence ASC
  FIRST_OCCURRENCE_START_TIMESTAMP_ASC

# Sort by start timestamp of the first occurrence DESC
  FIRST_OCCURRENCE_START_TIMESTAMP_DESC
}

input AssignmentInput {
  resource_id: ID
  owner_account: AccountInput
  payer_account: AccountInput
  price_frequency: RecurrenceFrequency
  price_interval: Int
  price: Float
  deposit_amount: Float
  setup_fee: Float
  override_tax_rate: Boolean
  tax_rate: Float
  override_inclusive_tax_rate: Boolean
  inclusive_tax_rate: Float
  first_occurrence_start_timestamp: Int
  last_occurrence_end_timestamp: Int
  no_end: Boolean
  duration_sec: Int
  notes: String
  recurrence: RecurrenceInput
  cancellation_policy: CancellationPolicyInput
}

type AssignmentChange {
  assignment: Assignment!
  invoices: [ChangeInvoice!]!
}

type Attachments {
  accounts: [Account!]!
  account_plans: [AccountPlan!]!
  assignments: [Assignment!]!
  bookings: [Booking!]!
  conversations: [Conversation!]!
  files: [FileData!]!
  invoices: [Invoice!]!
  issues: [Issue!]!
  messages: [ConversationMessage!]!
  notes: [Note!]!
  plan_templates: [PlanTemplate!]!
  products: [Product!]!
  product_sales: [ProductSale!]!
  resources: [Resource!]!
  tasks: [Task!]!
  tours: [Tour!]!
  count: Int!
  account_count: Int!
  account_plan_count: Int!
  assignment_count: Int!
  booking_count: Int!
  conversation_count: Int!
  file_count: Int!
  invoice_count: Int!
  issue_count: Int!
  message_count: Int!
  note_count: Int!
  plan_template_count: Int!
  product_count: Int!
  product_sale_count: Int!
  resource_count: Int!
  task_count: Int!
  tour_count: Int!
  metadata: [AttachmentsMetadata!]
}

type AttachmentsMetadata {
  object_type: ObjectType!
  object_id: ID!
  organization_id: ID!
  organization_name: String!
  error: String
}

input AttachmentInput {
  object_type: ObjectType!
  object_id: ID!
}

input AttachmentSearchInput {
  account_plan: AccountPlanSearchInput
  invoice: InvoiceSearchInput
  product_sale: ProductSaleSearchInput
}

type AvailabilityBlock {
# Block ID
  availability_block_id: ID!

# Block name
  name: String!
  first_occurrence_start_datetime: DateTime!
  first_occurrence_end_datetime: DateTime!
  last_occurrence_end_datetime: DateTime
  is_recurring: Boolean!
  recurrence: Recurrence

# Whether to block all locations
  in_all_locations: Boolean!

# Blocked locations
  locations: [Location!]!

# Date created
  created_timestamp: Int!

# The user who created this block
  created_by_user: User
}

input AvailabilityBlockInput {
  name: String
  first_occurrence_start_datetime: DateTime
  first_occurrence_end_datetime: DateTime
  last_occurrence_end_datetime: DateTime
  recurrence: RecurrenceInput
  in_all_locations: Boolean = true
  location_id: [ID!]
}

# Booking pagination wrapper
type BookingPagination {
# The number of available elements
  total: Int!

# List of bookings
  data: [Booking]!
}

# Order of the bookings
enum BookingOrder {
# Sort by creation timestamp ASC
  CREATED_TIMESTAMP_ASC

# Sort by creation timestamp DESC
  CREATED_TIMESTAMP_DESC

# Sort by start timestamp ASC
  START_TIMESTAMP_ASC

# Sort by start timestamp DESC
  START_TIMESTAMP_DESC

# Sort by end timestamp ASC
  END_TIMESTAMP_ASC

# Sort by end timestamp DESC
  END_TIMESTAMP_DESC
}

# Booking
type Booking {
# Booking unique ID
  booking_id: ID!
  organization_id: ID!

# Account related to this booking
  account: Account

# Location associated with this booking
  location: Location

# The resource booked
  resource: Resource

# Booking title
  title: String

# Booking notes
  notes: String
  body: String @deprecated(reason: "Replaced by notes")

# Period of booking
  period: BookingPeriod @deprecated

# Quantity of the same resource, for example 5 for five desks
  quantity: Int @deprecated

# Duration of the booking, based on the period unit
  duration: Float @deprecated

# Start date/time of the booking
  start_timestamp: Int!
  check_in_timestamp: Int! @deprecated(reason: "Replaced by start_timestamp")

# End date/time of the booking
  end_timestamp: Int!
  check_out_timestamp: Int! @deprecated(reason: "Replaced by end_timestamp")

# Booking generation date
  created_timestamp: Int!

# Time/date when booking ended
  ended_timestamp: Int

# The user associated with this booking
  user: User

# The user who created this booking
  created_by_user: User

# Whether this booking is not reviewed
  is_new: Boolean!

# Whether this booking has been approved but not canceled
  is_approved: Boolean!

# Whether this booking is completed
  is_completed: Boolean! @deprecated

# Whether this booking has been canceled
  is_canceled: Boolean!

# Whether this booking was rejected
  is_rejected: Boolean!

# Origin of the booking
  origin: BookingOrigin

# Detailed info about the charges made to the user regarding this booking
  cost: BookingCost @deprecated(reason: "Replaced by payment")

# Booking invitees
  invitees: [BookingInvitee]

# Information regarding the plan usage as generated by this booking
  plan_usage: [BookingPlanUsage] @deprecated(reason: "Replaced by payment")

# Public booking confirmation link
  web_link(
# Provides a restricted web link that does not show billing information and cannot be used to edit/cancel the booking
    shareable: Boolean = false
  ): String

# Online meeting rooms
  online_meeting: [BookingOnlineMeeting!]

# External calendar ID
  external_id: String
  is_recurring: Boolean!
  is_recurrence_exception: Boolean
  recurrence: Recurrence

# Booking source (e.g. Drop-in)
  source: String

# Whether this booking should be hidden from users
  is_hidden: Boolean!

# Information about the charges and wallet access usage
  payment: Payment

# Invoices related to this booking
  invoices: [Invoice!]!

# Invoice items related to this booking
  invoice_items: [PendingInvoiceItem!]!
}

type BookingCost {
  total_amount: Float
  total_invoiced: Float
  total_pending: Float

# For example USD, EUR, JPY, or BRL
  currency: String

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float
  tax_amount: Float
  resource_price: Float
  unit: BookingUnit
}

type BookingOnlineMeeting {
  meeting_id: String!
  join_url: String!
  toll_number: String
  toll_free_number: String
  pass_code: String
}

type BookingInvitee {
  user: User!
  status: InviteeStatus!
}

# Provide one of the following: (user_id), (email), (email, name)
input BookingInviteeInput {
# User ID of an existing user
  user_id: ID

# Email of a new or existing user
  email: String

# Name of a new user
  name: String

# Invitee status
  status: InviteeStatus = PENDING
}

type BookingSet {
  booking_session_id: ID!
  account: Account!
  owner: User!
  created_by_user: User
  recurrence: Recurrence
  processing: Boolean @deprecated(reason: "The booking operations are not queued anymore")
  bookings: [BookingSetElement]!
}

input BookingSetInput {
  booking_session_id: ID
  account: AccountInput
  owner_user_id: ID

# Booking preferences (default: start now, 30 minutes duration)
  preferences: BookingPreferencesInput
  recurrence: BookingRecurrenceInput

# Source of the new bookings (e.g. "Drop-in", "Mobile app", etc.)
  source: String

# Title (max length: 255)
  title: String
  notes: String

# Don't create invoice credits for canceled bookings
  no_refund: Boolean
  bookings: [BookingSetElementInput!]
}

type BookingSetElement {
  booking_id: ID
  start_timestamp: Int!
  end_timestamp: Int!
  ended_manually_timestamp: Int
  resource_id: [ID!]!
  resources: [Resource!]!
  payment: BookingPayment
  available_payments: [BookingPayment!]
  is_confirmed: Boolean!
  is_canceled: Boolean!
  is_cancelled: Boolean! @deprecated(reason: "Replaced by is_canceled")
  is_recurring: Boolean!
  is_recurrence_exception: Boolean!
  source: String
  title: String
  notes: String
  invitees: [BookingInvitee!]
  create_online_meeting: Boolean!
  is_external: Boolean!
  external_id: String
  total_invoiced: Float!
  total_pending: Float!
  alternative_bookings: [BookingSetElement!]
}

input BookingSetElementInput {
  booking_id: ID
  start_timestamp: Int
  end_timestamp: Int
  resource_id: [ID!]

# Payment preferences if the booking incurs any cost
  payment: BookingPaymentInput

# Cancel the booking
  is_canceled: Boolean

# Cancel the booking (deprecated: replaced by is_canceled)
  is_cancelled: Boolean

# End the booking immediately
  is_ended_manually: Boolean

# Invite new or existing users to the booking
  invitees: [BookingInviteeInput!]

# Create online meeting room when creating a booking, if an integration is available
  create_online_meeting: Boolean = true
  external_id: String

# Deprecated: replaced with RecurrenceInput.skipped_timestamps
  exception_original_start_timestamp: Int

# Deprecated: replaced with RecurrenceInput.skipped_timestamps
  skip_occurrence: Boolean
}

input BookingPreferencesInput {
  resource: ResourceSearchInput
  start_timestamp: Int
  end_timestamp: Int

# Duration, used only when missing start or end timestamp
  duration_sec: Int = 1800

# Require either all, or none bookings starting at the specified time
  required_count: Int

# The start time for the required number of bookings
  required_start_timestamp: Int

# Deprecated; use the same allowance for all bookings
  use_same_allowance: Boolean = false
}

type BookingPayment {
  account: Account!
  allowance_usage: [AllowanceUsage!] @deprecated

# Item quantity
  quantity: Float!

# The item unit amount
  unit_amount: Float!

# The item unit amount without a discount applied
  unit_amount_without_discount: Float!

# Price description (e.g. "$5.00/hour", "CA$10.00/day", etc.)
  price_description: String!

# Conditional pricing name, NULL if the default pricing was applied
  resource_conditional_pricing_name: String

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float!

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float!

# Tax
  tax: Float!

# Included tax
  included_tax: Float!

# The total cost of the item including tax
  total: Float!
  accesses: [WalletAccessUsage!]!
  allowance_unit: Unit

# Allowance available before the payment
  allowance_available: Float

# Allowance used for this payment
  allowance_used: Float

# Allowance remaining for this payment
  allowance_remaining: Float

# Description of allowance available before the payment
  allowance_available_description: String

# Description of allowance used for this payment
  allowance_used_description: String

# Description of allowance remaining for this payment
  allowance_remaining_description: String

# Unlimited allowance in effect
  unlimited_allowance: Boolean!
  discount_pct: Float
  price_override: Float
}

# Status of the invitation
enum InviteeStatus {
  PENDING
  ATTENDING
  NOT_ATTENDING
  MAYBE
}

# Booking period (deprecated: replaced by BookingUnit)
enum BookingPeriod {
  HOUR
  DAY
  MONTH
}

# Booking unit
enum BookingUnit {
  HOUR
  DAY
  MONTH
}

# Origin of the booking
enum BookingOrigin {
# From Sharedesk platform
  MARKETPLACE

# From Optix app/manager
  OPTIX

# Created by a external calendar (e.g. Google calendar)
  EXTERNAL
}

type ResourceBulkDraft {
# The number of resources
  total: Int!

# Resource type
  resource_type_id: ID

# Resource type group
  resource_type_group_id: ID

# Resource capacity
  capacity: Int

# Whether this resource is assignable
  is_assignable: Boolean

# Assignment price per month
  assignment_price_month: Float

# Booking price per hour
  booking_price_hour: Float @deprecated(reason: "Replaced by prices")

# Booking price per day
  booking_price_max: Float @deprecated(reason: "Replaced by prices")

# Booking prices
  prices: [Price!]!

# Override the default invoicing settings
  override_tax_rate: Boolean

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float

# Override the default invoicing settings
  override_inclusive_tax_rate: Boolean

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float

# Resource size (square meters)
  size_sq_meters: Float

# Indicates whether this resource can be booked
  bookable_by: BookableBy

# Whether bookings at any time of the day are allowed
  is_bookable_outside_service_hours: Boolean

# Whether the repeat bookings are allowed
  can_have_repeat_bookings: Boolean

# Minimum booking time (in seconds)
  min_booking_duration_sec: Int

# Maximum booking time (in seconds)
  max_booking_duration_sec: Int

# The minimum time before the same user can book the resource again (in seconds)
  no_return_sec: Int

# The minimum time before users can book a resource again (in seconds)
  buffer_time_sec: Int
}

enum BookableBy {
  ALL
  ADMINS_ONLY
  NONE
}

type AccountPlanBulkDraft {
# The number of plans
  total: Int!

# Plan name
  name: String

# The maximum start timestamp
  max_start_timestamp: Int

# End timestamp
  end_timestamp: Int

# Whether this plan has no end date
  no_end: Boolean

# Plan price
  price: Float

# Billing frequency
  price_frequency: PlanFrequency

# Override the default invoicing settings
  override_tax_rate: Boolean

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float

# Override the default invoicing settings
  override_inclusive_tax_rate: Boolean

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float

# Common included items
  accesses: [Access!]!

# Allowance and access renewal frequency
  allowance_renewal_frequency: PlanFrequency

# Plan terms
  terms: String
}

type OrganizationCalendar {
  provider: CalendarProvider!
  account_email: String
  is_connected: Boolean!
}

# Calendar
type Calendar {
# Calendar unique ID
  calendar_id: ID!

# Provider
  provider: CalendarProvider!

# External calendar ID
  provider_calendar_id: ID!

# Calendar type
  type: CalendarType!

# Calendar name
  name: String!

# Resource linked to calendar
  resource: Resource

# Location linked to calendar
  location: Location
}

input CalendarsInput {
# Location ID
  location_id: ID

# Resource ID
  resource_id: ID

# List of the connected calendars
  calendars: [CalendarInput!]!
}

input CalendarInput {
# External calendar ID
  provider_calendar_id: ID!

# Calendar name
  name: String!
}

# Available calendar providers
enum CalendarProvider {
  GOOGLE
  EXCHANGE
  OPTIX
}

# Calendar type
enum CalendarType {
  NOT_CONNECTED
  RESOURCE
  LOCATION
}

# Calendar provider credentials
type CalendarProviderCredentials {
# Calendar provider credentials ID
  calendar_provider_credentials_id: ID!

# User
  user: User!

# Organization
  organization: Organization!

# Created date
  created_timestamp: Int!
}

# Check-in pagination wrapper
type CheckinPagination {
# The number of available elements
  total: Int!

# List of check-ins
  data: [Checkin]!
}

# Check-in
type Checkin {
# Check-in unique ID
  checkin_id: ID!

# Owner account
  owner_account: Account!

# Payer account
  payer_account: Account!

# Location associated with this check-in
  location: Location!

# Time of check-in
  start_timestamp: Int!

# Time of check-out
  end_timestamp: Int!

# Time of check-in
  check_in_time: Int! @deprecated(reason: "Consider using start_timestamp")

# Checked in member
  member: Member! @deprecated(reason: "Replaced by owner account and payer account")

# Information about the charges and wallet access usage
  payment: Payment

# Invoices related to this check-in
  invoices: [Invoice!]!

# Invoice items related to this check-in
  invoice_items: [PendingInvoiceItem!]!
  created_by_user: UserProfile
  created_timestamp: Int!
}

input CheckinInput {
  owner_account: AccountInput
  payer_account: AccountInput
  location_id: ID
  start_timestamp: Int
}

type CheckinChange {
  checkin: Checkin!
  available_payments: [Payment!]!
  payment: Payment
  invoices: [ChangeInvoice!]!
}

# Condition parameter; value, variable, and property_id are mutually exclusive
type ConditionParameter {
  value: String
  variable: EvaluableVariable
  property_id: ID

# Modifier for a date (days, weeks, or months), e.g. "plus 3 days"
  date_modifier: Duration
  wallet_allowance_variable_parameters: WalletAllowanceVariableParameters
}

# Condition parameter; value, variable, and property_id are mutually exclusive
input ConditionParameterInput {
  value: String
  variable: EvaluableVariable
  property_id: ID

# Modifier for a date (days, weeks, or months), e.g. "plus 3 days"
  date_modifier: DurationInput
  wallet_allowance_variable_parameters: WalletAllowanceVariableParametersInput
}

type EvaluableCondition {
  condition_operation: ConditionOperation!
  condition_parameters: [ConditionParameter!]
  conditions: [EvaluableCondition!]
}

input EvaluableConditionInput {
  condition_operation: ConditionOperation
  condition_parameters: [ConditionParameterInput!]
  conditions: [EvaluableConditionInput!]
}

# Order of the documents
enum DocumentOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC

# Sort by status ASC
  STATUS_ASC

# Sort by status DESC
  STATUS_DESC

# Sort by account name ASC
  ACCOUNT_NAME_ASC

# Sort by account name DESC
  ACCOUNT_NAME_DESC

# Sort by creation date ASC
  CREATED_TIMESTAMP_ASC

# Sort by creation date DESC
  CREATED_TIMESTAMP_DESC
}

input DocumentSearchInput {
# Filter by document ID
  document_id: [ID!]

# Search by document name or account name
  search: String

# Filter by status
  status: [DocumentStatus!]

# Filter by account
  account_id: ID

# Documents created after the timestamp (inclusive)
  created_timestamp_from: Int

# Documents created before the timestamp (inclusive)
  created_timestamp_to: Int

# Filter by label
  label_id: [ID!]
}

type DocumentPagination {
  total: Int!
  total_without_filters: Int!
  data: [Document!]!
}

type Document {
  document_id: ID!
  account: Account!
  name: String!
  status: DocumentStatus!
  can_be_resent: Boolean!
  related_object_type: ObjectType
  related_object_id: ID
  labels: [Label!]!
  latest_file: FileData
  created_by: DocumentCreator!
  created_timestamp: Int!
  updated_timestamp: Int!
}

type DocumentDraft {
  name: String!
  base64_content: String!
}

union DocumentCreator = User | Workflow

input DocumentInput {
  account: AccountInput!

# For team accounts, choose a specific team admin
  signer_user_id: ID
  name: String!
  contents_url: String
  contents: String
  addendum_url: String
  addendum: String
  expiration_timestamp: Int
  admin_signer_user_id: ID
  primary_location_admin_is_signer: Boolean
}

type EventTrackResponse {
  success: Boolean
}

type FeatureSettings {
  remove_optix_branding: Boolean!
  remove_optix_branding_for_admins: Boolean!
  enable_app_help_center: Boolean!
  enable_optix_support_widget: Boolean!
  enable_whats_new: Boolean!
  enable_bento: Boolean!
  enable_contact_admin: Boolean!
  require_custom_terms_agreement: Boolean!
  enable_assignments: Boolean!
  enable_bookings: Boolean!
  enable_checkins: Boolean!
  users_can_cancel_checkins: Boolean!
  enable_community_directory: Boolean!
  default_show_in_directory: Boolean!
  enable_feed: Boolean!
  enable_documents: Boolean!
  enable_document_signing: Boolean!
  enable_products: Boolean!
  custom_products_header: String
  enable_issues: Boolean!
  enable_teams: Boolean!
  users_can_create_teams: Boolean!
  enable_dropin_booking_widget: Boolean!
  enable_signup_widget: Boolean!
  enable_tour_widget: Boolean!
  show_i_was_invited: Boolean!
  enable_plans: Boolean!
  require_allowance_use: Boolean!
  enable_allowance: Boolean! @deprecated(reason: "Please use enable_plans")
  location_switcher_experience: LocationSwitcherExperience! @deprecated(reason: "Replaced by MobileFeatureSettings")
  plan_version: Int!
  enable_custom_unit: Boolean!
  custom_unit: Unit

# Whether users should only see resources related to the owned accesses
  restrict_resource_visibility: Boolean!

# Whether users should only see products related to the owned accesses
  restrict_product_visibility: Boolean!
  users_can_choose_plan_start_date: Boolean!
  require_plan_or_allowance: Boolean!
  plans_end_soon_days: Int!
  enable_plan_credits: Boolean!
  default_start_billing_on: PlanBillingStart!
  default_initial_invoice_due: PlanInitialInvoice!
  custom_invoice_header: String
  custom_invoice_org_name: String
  invoice_header: String!
  custom_tax_name: String
  tax_name: String!
  tax_mode: TaxMode!
  require_paying_overdue_invoices: Boolean!
  qr_code_style: String
  qr_code_includes_logo: Boolean!
  qr_code_color: String
  promote_plan_title: String
  promote_plan_description: String
  promote_pass_title: String
  promote_pass_description: String
  pass_order: ObjectOrder!
  plan_template_order: ObjectOrder!
  product_order: ObjectOrder!
  notify_booking_invitees: Boolean!
  show_user_names_in_schedule: Boolean!
  mobile: MobileFeatureSettings!
  in_silent_mode: Boolean!
  enable_payments: Boolean!
  apply_credit_automatically: Boolean!
  payment_method_policy: PaymentMethodPolicy!
  auto_payment_policy: AutoPaymentPolicy!
  additional_charge_mode: AdditionalChargeMode!
  days_to_overdue: Int!
  send_invoices_before: Int! @deprecated(reason: "The logic for invoice notifications has been moved to automations")
  add_transaction_fees: Boolean!
  enable_pending_invoice_payments: Boolean!
  enable_tasks: Boolean!
  inbox: Feature!
  inbox_users_can_create_public_groups: Boolean!
  automations: Feature!
  automations_current_included_actions: Int!
  automations_current_cycle_end_timestamp: Int!
  automations_current_cycle_actions_count: Int!
  enable_automations_additional_actions: Boolean!
}

type Feature {
  status: FeatureStatus!

# If the enabled feature has a free trial, it indicates when a trial ends
  free_trial_end_timestamp: Int
  days_remaining_on_trial: Int
  price: FeaturePrice
}

input FeatureSettingsInput {
  enable_assignments: Boolean
  enable_bookings: Boolean
  enable_checkins: Boolean
  users_can_cancel_checkins: Boolean
  enable_community_directory: Boolean
  default_show_in_directory: Boolean
  enable_documents: Boolean
  enable_document_signing: Boolean
  enable_feed: Boolean
  users_can_post: Boolean
  users_can_comment: Boolean
  enable_products: Boolean
  custom_products_header: String
  enable_issues: Boolean
  enable_teams: Boolean
  users_can_create_teams: Boolean
  enable_dropin_booking_widget: Boolean
  enable_signup_widget: Boolean
  enable_tour_widget: Boolean
  custom_unit: String
  enable_custom_unit: Boolean
  require_allowance_use: Boolean
  enable_plans: Boolean

# Whether users should only see resources related to the owned accesses
  restrict_resource_visibility: Boolean

# Whether users should only see products related to the owned accesses
  restrict_product_visibility: Boolean
  users_can_choose_plan_start_date: Boolean
  require_plan_or_allowance: Boolean
  plans_end_soon_days: Int
  enable_plan_credits: Boolean
  default_start_billing_on: PlanBillingStart
  default_initial_invoice_due: PlanInitialInvoice
  tax_mode: TaxMode
  require_paying_overdue_invoices: Boolean
  qr_code_style: String
  qr_code_includes_logo: Boolean
  qr_code_color: String
  promote_plan_title: String
  promote_plan_description: String
  promote_pass_title: String
  promote_pass_description: String
  pass_order: ObjectOrder
  plan_template_order: ObjectOrder
  product_order: ObjectOrder
  notify_booking_invitees: Boolean
  user_registration_policy: UserRegistrationPolicy
  users_can_skip_required_sections: Boolean
  show_user_names_in_schedule: Boolean
  require_custom_terms_agreement: Boolean
  location_switcher_experience: LocationSwitcherExperience
  in_silent_mode: Boolean
  apply_credit_automatically: Boolean
  payment_method_policy: PaymentMethodPolicy
  auto_payment_policy: AutoPaymentPolicy
  additional_charge_mode: AdditionalChargeMode
  days_to_overdue: Int
  send_invoices_before: Int
  add_transaction_fees: Boolean
  enable_pending_invoice_payments: Boolean
  enable_tasks: Boolean
  custom_invoice_header: String
  custom_invoice_org_name: String
  custom_tax_name: String
  inbox_status: FeatureStatus
  inbox_users_can_create_public_groups: Boolean
  automations_status: FeatureStatus
  automations_current_included_actions: Int
  enable_automations_additional_actions: Boolean
}

type MobileFeatureSettings {
  user_registration_policy: UserRegistrationPolicy!
  users_can_post: Boolean!
  users_can_comment: Boolean!
  users_can_skip_required_sections: Boolean!
  location_switcher_experience: LocationSwitcherExperience!
  enable_location_services: Boolean!
}

enum LocationSwitcherExperience {
  LIST
  MAP
}

enum TaxMode {
  NONE
  EXCLUSIVE
  INCLUSIVE
}

enum UserRegistrationPolicy {
  INVITATION_ONLY
  CAN_REQUEST_ACCESS
  CAN_REGISTER
}

enum PaymentMethodPolicy {
  NOT_REQUIRED
  ALWAYS_REQUIRED
  REQUIRED_ON_FIRST_CHARGE
}

enum AutoPaymentPolicy {
  EDITABLE_DEFAULT_OFF
  EDITABLE_DEFAULT_ON
  NON_EDITABLE_DEFAULT_OFF
  NON_EDITABLE_DEFAULT_ON
}

# A file to be uploaded
input FileUpload {
# Base64 file content
  base64_content: String

# Temporary URL of pre-uploaded file (generated by fileUpload mutation)
  url: String
}

# A file content
type FileData {
# Generated file name
  name: String

# Original file name (provided as "name" to "fileUpload")
  origin_name: String

# Generated URL of the file
  url: String

# MIME type
  mime: String

# Size of the file
  size: Int

# Width (only for images)
  width: Int

# Height (only for images)
  height: Int

# Date uploaded
  timestamp: Int

# File ID to be used with object_type=FILE for attachments
  uploaded_data_id: ID
}

enum FileUsage {
  ANNOUNCEMENTS
  APPS
  ATTACHMENTS
  DOCS_TO_SIGN
  FEED_POSTS
  LOCATIONS
  MOBILE_APPS
  ORGANIZATIONS
  PRODUCT_COLLECTIONS
  PRODUCTS
  RESOURCE_TYPE_GROUPS
  RESOURCES
}

# Invoice item
type InvoiceItem {
# ID of the invoice item. This value is empty for the items from invoice drafts.
  item_id: ID

# Unique signature, which can be used to select the pending items when creating a new invoice. This value is empty for new custom items from invoice drafts, and also for the items from the finalized invoices.
  temporary_signature: String

# ID of the pending item. This value is empty for projected charges or new custom items from invoice drafts, and also for the items from the finalized invoices.
  pending_invoice_item_id: ID

# Item name
  name: String!

# Item description
  description: String!

# Item quantity
  quantity: Float!

# The item cost
  price: Float!

# The total cost of the item before tax
  subtotal: Float!

# Tax
  tax: Float

# Included tax
  included_tax: Float

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float

# The total cost of the item including tax
  total: Float!

# Information regarding the origin of this invoice item. Useful for accounting integration.
  origin: InvoiceItemOrigin!
}

# Invoice item origin, describing what generated the invoice item
type InvoiceItemOrigin {
# The main type of the item
  type: InvoiceItemOriginType!

# Plan associated with this item
  plan: Plan @deprecated

# Booking associated with this item
  booking: Booking

# Check-in associated with this item
  checkin: Checkin

# Product sale associated with this item
  product_sale: ProductSale

# Assignment associated with this item
  assignment: Assignment

# Account plan associated with this item
  account_plan: AccountPlan
}

# Types of origin of invoice items
enum InvoiceItemOriginType {
# Account plan
  ACCOUNT_PLAN

# Account plan deposit
  ACCOUNT_PLAN_DEPOSIT

# Account plan setup fee
  ACCOUNT_PLAN_SETUP

# Assignment
  ASSIGNMENT

# Assignment deposit
  ASSIGNMENT_DEPOSIT

# Assignment setup fee
  ASSIGNMENT_SETUP

# Booking
  BOOKING

# Check-in at the organization location
  CHECKIN

# Item created by an administrator
  CUSTOM

# Custom allowance added by an administrator
  CUSTOM_ALLOWANCE

# Pass sale
  PASS_SALE

# Product sale
  PRODUCT_SALE

# Subscription
  SUBSCRIPTION

# Subscription deposit
  SUBSCRIPTION_DEPOSIT

# Subscription setup fee
  SUBSCRIPTION_SETUP

# Transaction fee
  TRANSACTION_FEE
}

# Updatable invoice item input
input InvoiceItemInput {
# Item name (e.g. Print service)
  name: String

# Item description (e.g. 5 pages)
  description: String

# Exclusive tax rate (e.g. 5 for 5%, max: 99.9999)
  tax_rate: Float

# Inclusive tax rate (e.g. 5 for 5%, max: 99.9999)
  inclusive_tax_rate: Float

# Price for each unit of this item
  unit_amount: Float

# Quantity
  quantity: Float = 1
}

# Updatable invoice sale input
input InvoiceSaleInput {
# ID of the product related to the sale item
  product_id: ID!

# ID of the location related to the sale item
  location_id: ID

# Item name (e.g. Print service)
  name: String

# Item description (e.g. 5 pages)
  description: String

# Exclusive tax rate (e.g. 5 for 5%, max: 99.9999)
  tax_rate: Float

# Inclusive tax rate (e.g. 5 for 5%, max: 99.9999)
  inclusive_tax_rate: Float

# Price for each unit of this item
  unit_amount: Float

# Quantity
  quantity: Float = 1
}

# Pending invoice item to be included in the invoice
input PendingInvoiceItemInput {
# Unique signature of the pending invoice item
  temporary_signature: String!
}

# Pending invoice item
type PendingInvoiceItem {
# ID of the pending invoice item
  pending_invoice_item_id: ID

# Unique signature of the pending invoice item
  temporary_signature: String

# Item name
  name: String!

# Item description
  description: String!

# Item quantity
  quantity: Float!

# The item unit amount
  unit_amount: Float!

# Tax
  tax: Float

# Included tax
  included_tax: Float

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float

# The total cost of the item including tax
  total: Float!

# Start timestamp for subscription periods
  start_timestamp: Int

# End timestamp for subscription periods
  end_timestamp: Int
  account: Account!
  invoice_due_timestamp: Int
  expected_invoicing_timestamp: Int
  origin_type: InvoiceItemOriginType!
  account_plan_id: ID
  assignment_id: ID
  booking_id: ID
  checkin_id: ID
  product_sale_id: ID
  invoice_id: ID
  invoice_number: String
  invoice_status: InvoiceStatus!
  invoice_item_id: ID
}

type PendingInvoiceItemPagination {
  total: Int!

# If nothing found, try without the location filter applied
  found_in_all_locations: Boolean!
  total_in_all_locations: Int! @deprecated(reason: "Replaced by found_in_all_locations")

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")
  data: [PendingInvoiceItem!]
  export_csv: String
}

# Order of the invoice items
enum InvoiceItemOrder {
# Sort by number ASC
  INVOICE_NUMBER_ASC

# Sort by number DESC
  INVOICE_NUMBER_DESC

# Sort by due date ASC
  INVOICE_DUE_TIMESTAMP_ASC

# Sort by due date DESC
  INVOICE_DUE_TIMESTAMP_DESC

# Sort by invoice status ASC
  INVOICE_STATUS_ASC

# Sort by invoice status DESC
  INVOICE_STATUS_DESC

# Sort by total ASC
  TOTAL_ASC

# Sort by total DESC
  TOTAL_DESC

# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC

# Sort by account name ASC
  ACCOUNT_NAME_ASC

# Sort by account name DESC
  ACCOUNT_NAME_DESC
}

# Invoice tag
type InvoiceTag {
# Invoice tag unique ID
  tag_id: ID!

# Invoice unique ID
  invoice_id: ID!

# Tag name
  tag_name: String!

# Tag color
  color: String!

# Date created
  created: Int!
}

# Tag color type
enum TagColor {
# Green
  GREEN

# Red
  RED

# Blue
  BLUE

# Yellowfins
  YELLOWFINS
}

# InvoiceTransaction
type InvoiceTransaction {
# Invoice transaction unique ID
  transaction_id: ID!

# The source of the credit (for BALANCE_CREDIT) or the destination for the credit (for BALANCE_DEBIT)
  related_invoice_id: ID

# The corresponding debit transaction (for BALANCE_CREDIT) or the credit transaction (for BALANCE_DEBIT)
  related_transaction_id: ID

# The invoice
  invoice: Invoice

# Transaction type
  type: InvoiceTransactionType

# Transaction description (e.g. "Manual payment")
  description: String!

# Payment description (e.g. "Automatic payment for $100 from Visa ending in 9999")
  payment_description: String
  details: String! @deprecated(reason: "Replaced by description")

# Payment gateway (e.g. Stripe, Spreedly, Visa Credit Card, etc.)
  gateway: String

# Gateway transaction ID
  gateway_transaction: String

# The date the transaction was created
  timestamp: Int!

# The date the transaction was removed
  canceled_timestamp: Int

# The date the transaction was removed
  cancelled_timestamp: Int @deprecated(reason: "Replaced by canceled_timestamp")

# Amount associated with this transaction
  amount: Float

# Details of the payment method
  payment_method: PaymentMethod

# Type of a manual payment (e.g. "ACH direct deposit", "Cash", etc.)
  manual_payment_type: String
}

# Transaction pagination wrapper
type InvoiceTransactionPagination {
# The number of available elements
  total: Int!

# If nothing found, try without the location filter applied
  found_in_all_locations: Boolean!
  total_in_all_locations: Int! @deprecated(reason: "Replaced by found_in_all_locations")

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of transactions
  data: [InvoiceTransaction]!
}

enum InvoiceTransactionStatus {
# Transaction is active
  ACTIVE

# Transaction was removed
  REMOVED
}

# Transaction payment source
enum InvoiceTransactionPaymentMethod {
# A debit or credit card
  CARD

# A bank account
  BANK

# Other
  OTHER
}

# Order of the transactions
enum InvoiceTransactionOrder {
# Sort ASC timestamp
  TIMESTAMP_ASC

# Sort DESC timestamp
  TIMESTAMP_DESC

# Sort by amount ASC
  AMOUNT_ASC

# Sort by amount DESC
  AMOUNT_DESC
}

# Invoice transaction type
enum InvoiceTransactionType {
# Payment against the invoice
  PAYMENT

# Refund amount
  REFUND

# Payment failure
  PAYMENT_FAILED

# Balance credit
  BALANCE_CREDIT

# Balance debit
  BALANCE_DEBIT

# Custom note assigned to invoice (e.g. "Error exporting to Xero")
  NOTE

# Payment intent that can result in a PAYMENT or PAYMENT_FAILED
  PAYMENT_INTENT
}

input PrimaryLocationInput {
# Filter by list of locations
  primary_location_id: [ID] = []

# Include accounts with no primary location
  include_nomad: Boolean = true
}

# Invoice pagination wrapper
type InvoicePagination {
# The number of available elements
  total: Int!

# If nothing found, try without the location filter applied
  found_in_all_locations: Boolean!
  total_in_all_locations: Int! @deprecated(reason: "Replaced by found_in_all_locations")

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of invoices
  data: [Invoice]!
}

# Invoice billing details
type InvoiceBillingDetails {
# Account ID
  account_id: ID!

# Billing name
  name: String

# Street address
  address: String

# Street address line 2
  address2: String @deprecated

# Unit number
  unit: String

# City
  city: String

# State/province
  region: String

# Postal/ZIP code
  postcode: String

# Country
  country: String

# Email
  email: String

# Phone number
  phone: String @deprecated

# Tax number
  tax_number: String

# Payment instructions (available only in the 'from' section of the invoice)
  payment_instructions: String
}

input InvoiceBillingDetailsInput {
# Billing name
  name: String

# Street address
  address: String

# Unit number
  unit: String

# Postal/ZIP code
  postcode: String

# City
  city: String

# State/province
  region: String

# Country
  country: String

# Email
  email: String

# Tax number
  tax_number: String

# Payment instructions (available only in the 'from' section of the invoice)
  payment_instructions: String
}

# Invoice
type Invoice {
# Invoice unique ID
  invoice_id: ID!

# Invoice number
  number: String

# Invoice organization (invoice issuer)
  organization: Organization!

# The member owner of this invoice
  member: Member

# Account information
  account: Account

# The team owner of this invoice
  team: Team

# Invoice total before tax
  subtotal: Float

# Total tax amount
  tax: Float

# Invoice total including tax. If negative, this invoice is considered a credit note.
  total: Float

# Balance. If positive, this amount represents the amount due, otherwise it represents a credit amount.
  balance: Float

# Projected processing fee for a future payment, may be subject to change
  transaction_fee: Float

# Payment method type used to calculate the transaction fee
  transaction_fee_payment_method_type: String

# Transaction fee won't be auto-recalculated if set to true
  override_transaction_fee: Boolean!

# The date the invoice was created
  created_timestamp: Int!

# Due date
  due_timestamp: Int!

# Date of payment
  paid_timestamp: Int

# Expected invoicing time of the pending invoice
  expected_invoicing_timestamp: Int

# Notes for this invoice
  notes: String

# Indicates whether this invoice can be paid
  is_payable: Boolean!

# Indicates whether this invoice is upcoming
  is_upcoming: Boolean!

# Indicates whether this invoice is due
  is_due: Boolean!

# Indicates whether this invoice is overdue
  is_overdue: Boolean!

# Indicates whether this invoice has been paid
  is_paid: Boolean!

# Indicates whether this invoice has been voided
  is_void: Boolean!

# Indicates whether this invoice has a payment that is being processed
  is_processing: Boolean!

# Indicates whether this invoice has disabled auto/manual payments
  has_disabled_payments: Boolean!
  status: InvoiceStatus!

# Status of the auto-payment
  auto_payment_status: String

# Additional details about the auto-payment
  auto_payment_details: String

# Invoice items
  items: [InvoiceItem]!

# Invoice tags
  tags: [InvoiceTag]!

# Tax summary
  tax_summary: [TaxSummaryItem]

# Transaction summary, showing how much was paid/refunded
  transaction_summary: [TransactionSummaryItem]

# Invoice transactions
  transactions(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Filter by transaction types
    filter_by_type: [InvoiceTransactionType]
  ): InvoiceTransactionPagination!

# Billing details
  to: InvoiceBillingDetails!
  billing: InvoiceBillingDetails @deprecated(reason: "Replaced by to")

# Billing details
  from: InvoiceBillingDetails!

# Invoice header
  invoice_header: String

# Tax name (e.g. "Tax", "VAT", etc.)
  tax_name: String

# Public invoice link
  web_link: String
  payment_options: [InvoicePaymentOption!]
  transaction_fee_options: [InvoiceTransactionFeeOption!]
  notification_emails: [String!]!
}

enum InvoiceStatus {
  PENDING
  UPCOMING
  DUE
  OVERDUE
  PROCESSING
  PAID
  VOID
  UNKNOWN
}

# Summary of the item subtotals and accumulated tax for a particular tax rate
type TaxSummaryItem {
# Tax mode
  tax_mode: TaxMode

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float

# Total amount
  total_amount: Float

# Total tax
  total_tax: Float
}

# Invoice transaction summary.
type TransactionSummaryItem {
# Transaction type description
  description: String

# Transaction type
  type: InvoiceTransactionType

# Total
  total: Float
}

# Order of the invoices
enum InvoiceOrder {
# Sort by number ASC
  NUMBER_ASC

# Sort by number DESC
  NUMBER_DESC

# Sort by due date ASC
  DUE_DATE_ASC

# Sort by due date DESC
  DUE_DATE_DESC

# Sort by total ASC
  TOTAL_ASC

# Sort by total DESC
  TOTAL_DESC

# Sort by balance ASC
  BALANCE_ASC

# Sort by balance DESC
  BALANCE_DESC

# Sort by account name ASC
  ACCOUNT_NAME_ASC

# Sort by account name DESC
  ACCOUNT_NAME_DESC

# Sort by status ASC
  STATUS_ASC

# Sort by status DESC
  STATUS_DESC
}

input CreditTransactionInput {
# ID of the source credit note, i.e. the invoice with a negative balance
  from_invoice_id: ID!

# ID of the target unpaid invoice with a positive balance
  to_invoice_id: ID!

# Amount associated with this transaction
  amount: Float!
}

type InvoicePaymentOption {
  name: String!
  is_default: Boolean!
  payment_method_type: String
  type: InvoicePaymentOptionType!

# Details of the payment method (for type=STORED)
  stored_pm: PaymentMethod

# Whether the payment method was verified or not (for type=STORED)
  is_verified: Boolean

# Checkout URL (for type=CHECKOUT)
  url: String

# Whether to open the URL using an external app (for type=CHECKOUT)
  open_using_external_app: Boolean!

# Projected payment processing fee, based on `payment_method_type`
  transaction_fee: Float
}

type InvoiceTransactionFeeOption {
  name: String!
  payment_method_type: String!
  fee: Float
}

type ChangeInvoice {
  invoice_due_timestamp: Int!
  items: [ChangeInvoiceItem!]!
  subtotal: Float!
  tax_summary: [TaxSummaryItem]
  total: Float!
}

type ChangeInvoiceItem {
  name: String!
  description: String!
  quantity: Float!
  price: Float!
  tax: Float!
  included_tax: Float!
  origin_type: InvoiceItemOriginType!
  start_timestamp: Int
  end_timestamp: Int
}

input InvoiceSearchInput {
  member_id: ID
  team_id: ID
  invoice_id: [ID]
  tag_id: [ID!]
  tag: [String!]
  include_paid: Boolean
  include_void: Boolean
  include_upcoming: Boolean
  status: [InvoiceStatus!]
  due_from: Int
  due_to: Int
  search: String
  primary_location_id: [ID!]
}

enum InvoicePaymentOptionType {
# An option for manual payments, see `url`
  CHECKOUT

# An option for recurring payments, see `stored_pm`
  STORED
  UNKNOWN
}

type Issue {
  issue_id: ID!
  user: User!
  location: Location!
  resource: Resource
  category: String!
  issue: String!
  comment: String
  image: FileData
  created_timestamp: Int!
  tasks: [Task!]!
}

type Label {
# Label unique ID
  label_id: ID!

# Label name
  name: String!

# Original name
  original_name: String

# Label type
  type: LabelType!

# Label color
  color: LabelColor!

# Label is used by at least one entity
  is_used: Boolean!

# How many accounts are using the label, if any
  usage_count: Int

# Date created
  created_timestamp: Int!
}

enum LabelType {
  ACCOUNT
  PLAN_TEMPLATE
  PRODUCT
  SALE
  TASK
  WORKFLOW
  UNKNOWN
}

# Label color
enum LabelColor {
  DEEP_ORANGE
  ORANGE
  AMBER
  LIGHT_GREEN
  GREEN
  LIGHT_BLUE
  BLUE
  INDIGO
  PURPLE
  PINK
  BLACK
  GRAY
}

# Individual or team subscription
type PlanSubscription {
  subscription_id: ID!
  subscription_type: PlanSubscriptionType!
  account: Account!
  description: String!
  start_timestamp: Int!
  end_timestamp: Int!

# If the subscription is in effect or not
  active: Boolean!
  plan_id: ID!
  charged_plan_start_timestamp: Int
  charged_plan_end_timestamp: Int
  deposit: Float
  deposit_pending_invoice_item_id: ID
  deposit_refund_pending_invoice_item_id: ID
  set_up_fee: Float
  set_up_fee_pending_invoice_item_id: ID
}

enum PlanSubscriptionType {
  MEMBER
  TEAM_INDIVIDUAL
  TEAM_SHARED
}

# Subscription charges
type SubscriptionCharges {
  interval_charges: [PendingInvoiceItem]
  interval_refunds: [PendingInvoiceItem]
  deposit: PendingInvoiceItem
  setup: PendingInvoiceItem
  charged_from: Int!
  charged_until: Int!
  next_charge_timestamp: Int!
  previous_subscription: PlanSubscription
}

# Subscription draft
type SubscriptionDraft {
  plan_name: String!
  start_timestamp: Int!
  end_timestamp: Int
  terms: String

# Next account invoicing date
  next_invoicing_timestamp: Int!
  price_customization: String
  charges: SubscriptionCharges
  tax_summary: [TaxSummaryItem]
}

# Deprecated; allowance represents the amount of hours, days, or other units available for a specific period of time and/or the discount for overage charges. It can be used to pay for bookings, check-ins, etc.
type Allowance {
  allowance_id: ID!
  name: String!
  description: String!
  origin: String!

# Discount for overage charges (e.g. 5 for 5%)
  discount: Float!

# Start timestamp of the allowance period
  start_timestamp: Int!

# End timestamp of the allowance period
  end_timestamp: Int!

# Whether this allowance is unlimited
  is_unlimited: Boolean!

# Total allowance for the period (unless unlimited)
  total: Float

# Available allowance for the period (unless unlimited)
  available: Float

# Unit (e.g. "hour", "day", or a currency code for monetary values)
  unit: String!

# Plan subscription that provides the allowance
  plan_subscription: PlanSubscription
}

# Deprecated
type AllowanceUsage {
  allowance: Allowance!
  amount: Float!
}

# Deprecated
input AllowanceUsageInput {
  allowance_id: ID!

# Amount (default: maximum available)
  amount: Float
}

# Subscription plan
type Plan {
  plan_id: ID!
  name: String
  unit: String
  credit: String
  is_deleted: Boolean!
}

type PlanPagination {
# The number of available elements
  total: Int!

# List of plans
  data: [Plan]!
}

type BookingPlanUsage {
  mp_id: ID @deprecated
  op_id: ID @deprecated
  member: Member
  team: Team
  plan: Plan @deprecated
  plan_name: String @deprecated
  access_name: String @deprecated
  credit_used: Float
  overusage: Float
  member_discount: Float
  discount: Float
  type: BookingPlanUsageType!
}

enum BookingPlanUsageType {
  MEMBER
  TEAM
}

# Location pagination wrapper
type LocationPagination {
# The number of available elements
  total: Int!

# List of locations
  data: [Location]!
}

# Location
type Location {
# Location ID
  location_id: ID!
  organization_id: ID!

# Name of this location
  name: String

# Short description
  description: String

# Country
  country: String

# State/province
  region: String

# City
  city: String

# Neighborhood
  neighborhood: String

# Postal/ZIP code
  postcode: String

# Address
  address: String

# Directions to the location
  directions: String

# Unit
  unit: String

# Geo radius
  geo_radius: Int

# Coordinates overridden flag
  coordinates_overridden: Boolean

# Latitude
  latitude: Float

# Longitude
  longitude: Float

# Timezone (e.g. "America/Vancouver", "UTC", etc.)
  timezone: String

# The timezone name (e.g "Pacific Standard Time")
  timezone_name: String

# Office phone
  phone: String

# The Wi-Fi SSID for the location
  wifi_name: String

# The Wi-Fi password for the location
  wifi_password: String
  wifi_ip: String

# Welcome message
  welcome_message: String

# Whether this location has been deleted
  is_deleted: Boolean

# Whether the location is visible for the apps
  is_visible: Boolean

# Whether the location is hidden
  is_hidden: Boolean

# Lists all resources associated with one app at one specific organization
  resources(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: ResourceOrder = TITLE_ASC

# Returns bookable/non-bookable only. Null for both.
    is_bookable: Boolean

# Select only a few resources, by ID
    resource_id: [ID!]
  ): ResourcePagination!

# Lists all bookings associated with the current location
  bookings(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: BookingOrder

# Filter by user ID (for admins only). Use -1 to retrieve data associated with all users.
    user_id: ID

# Includes new bookings
    include_new: Boolean

# Includes approved bookings
    include_approved: Boolean

# Includes completed bookings (deprecated)
    include_completed: Boolean

# Includes canceled bookings
    include_canceled: Boolean

# Includes canceled bookings (deprecated: replaced by include_canceled)
    include_cancelled: Boolean

# Includes rejected bookings
    include_rejected: Boolean

# Only associated with specific resources
    resource_id: [ID]

# Only associated with specific locations
    location_id: [ID]

# Bookings starting after the timestamp (inclusive)
    start_timestamp_from: Int

# Bookings starting before the timestamp (inclusive)
    start_timestamp_to: Int

# Bookings ending after the timestamp (inclusive)
    end_timestamp_from: Int

# Bookings ending before the timestamp (inclusive)
    end_timestamp_to: Int

# Deprecated: use start_timestamp_from
    start_from: Int

# Deprecated: use start_timestamp_to
    start_to: Int

# Includes bookings the current user was invited to
    invited: [InviteeStatus!]
    booked_as: BookingAsType
    in_progress: Boolean
    is_hidden: Boolean
  ): BookingPagination!

# General email
  contact_email: String

# Primary contact
  contact: Contact!
  additional_contacts: [Contact!]
  website: String

# Location amenities
  amenities: [Amenity]

# Service hours within a given time interval
  service_hours(start_timestamp: Int!, end_timestamp: Int!): [TimeInterval!]!

# Service hours of the location
  local_service_hours: [TimeWithinWeekDay!]!

# Availability for the tours
  tour_availability(
# Start timestamp
    start_timestamp: Int!

# End timestamp, no more than 1 month ahead from the start timestamp
    end_timestamp: Int!
  ): [TimeInterval!]!

# Main image
  main_image: FileData

# Location images
  gallery: [FileData!]!
  images: [ImageSet!] @deprecated(reason: "Replaced by gallery")
  pictures: [ImageSet!] @deprecated(reason: "Replaced by gallery")

# Check-in prices
  checkin_prices: [Price!]!

# Override the default invoicing settings
  override_checkin_tax_rate: Boolean!

# Exclusive tax rate (e.g. 5 for 5%)
  checkin_tax_rate: Float

# Override the default invoicing settings
  override_checkin_inclusive_tax_rate: Boolean!

# Inclusive tax rate (e.g. 5 for 5%)
  checkin_inclusive_tax_rate: Float
  override_billing_address: Boolean!
  default_organization_billing_address: Boolean!
  override_tax_number: Boolean!
  override_payment_instructions: Boolean!
  billing: InvoiceBillingDetails

# Override the organization invoicing settings
  override_tax_rate: Boolean!

# Exclusive tax rate (e.g. 5 for 5%)
  exclusive_tax_rate: Float!

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float!
  main_collection_name: String
  collection_count: Int
}

input LocationInput {
  name: String
  is_visible: Boolean
  country: String
  region: String
  city: String
  neighborhood: String
  postcode: String
  address: String
  unit: String
  latitude: Float
  longitude: Float
  directions: String
  phone: String
  contact_email: String
  contact_user_id: ID
  additional_contact_user_id: [ID!]
  website: String

# Location images
  gallery: [FileUpload!]
  local_service_hours: [TimeWithinWeekDayInput!]

# The Wi-Fi SSID for the location
  wifi_name: String

# The Wi-Fi password for the location
  wifi_password: String

# Welcome message
  welcome_message: String
  override_billing_address: Boolean
  default_organization_billing_address: Boolean
  billing_address: String
  billing_unit: String
  billing_city: String
  billing_region: String
  billing_postcode: String
  billing_country: String
  override_tax_number: Boolean
  billing_tax_number: String
  override_payment_instructions: Boolean
  payment_instructions: String

# Amenities available at this location
  amenities: [ID!]

# Check-in prices
  checkin_prices: [PriceInput!]

# Override the default invoicing settings
  override_checkin_tax_rate: Boolean

# Exclusive tax rate (e.g. 5 for 5%)
  checkin_tax_rate: Float

# Override the default invoicing settings
  override_checkin_inclusive_tax_rate: Boolean

# Inclusive tax rate (e.g. 5 for 5%)
  checkin_inclusive_tax_rate: Float

# Override the organization invoicing settings
  override_tax_rate: Boolean

# Exclusive tax rate (e.g. 5 for 5%)
  exclusive_tax_rate: Float

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float
}

# Order of the locations
enum LocationOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC

# Sort by exclusive tax ASC
  EXCLUSIVE_TAX_RATE_ASC

# Sort by exclusive tax DESC
  EXCLUSIVE_TAX_RATE_DESC

# Sort by inclusive tax ASC
  INCLUSIVE_TAX_RATE_ASC

# Sort by inclusive tax DESC
  INCLUSIVE_TAX_RATE_DESC

# Sort by city ASC
  CITY_ASC

# Sort by city DESC
  CITY_DESC
}

# Mail provider
type MailProvider {
# Mail provider unique ID
  mail_provider_id: ID!
  user_id: ID

# Mail provider type
  type: MailProviderType!
  smtp: SMTP

# The connected account (for type=GMAIL or EXCHANGE)
  account_email: String
  usage_count: Int
}

type SMTP {
  server: String!
  port: String!
  username: String!
  from_email: String!
  from_name: String!
}

input MailProviderInput {
  smtp: SMTPInput
}

input SMTPInput {
  server: String!
  port: String!
  username: String!
  password: String!
  from_email: String!
  from_name: String!
}

# Member pagination wrapper
type MemberPagination {
# The number of available elements
  total: Int!

# List of members
  data: [Member]!
}

# Member
type Member {
# Member unique ID
  member_id: Int!

# Indicates whether the member is active
  is_active: Boolean!

# If the member is marked as inactive, any interaction by this member will make him active again
  is_inactive: Boolean!

# This member has been deleted
  is_deleted: Boolean!

# This member is marked as a lead
  is_lead: Boolean!

# Indicates whether the user is allowed to book
  is_allowed_to_book: Boolean!

# Indicates whether the user is allowed to check-in
  is_allowed_to_check_in: Boolean!
  is_allowed_to_checkin: Boolean! @deprecated(reason: "Replaced by is_allowed_to_check_in")

# Date of the first interaction of this user
  member_since: Int!

# User information
  user: User!

# List of active individual and team subscriptions
  plan_subscriptions: [PlanSubscription!]! @deprecated
}

# Order of the members
enum MemberOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC

# Sort by member creation timestamp ASC
  MEMBER_CREATION_ASC

# Sort by member creation timestamp DESC
  MEMBER_CREATION_DESC
}

type ConversationsUpdate {
  total: Int!
  unread_conversation_count: Int!
  unread_conversations: Int! @deprecated(reason: "Replaced by unread_conversation_count")
  unread_message_count: Int!
  unread_messages: Int! @deprecated(reason: "Replaced by unread_message_count")
  conversation_sequence_up_to: ID!
  conversation_sequence_from: ID!
  users: [UserProfile!]!
  has_more: Boolean!
  data: [Conversation!]!
}

type Conversation {
  conversation_id: ID!
  name: String!
  image: FileData!
  users: [ID!]!
  user_count: Int!
  user: UserProfile! @deprecated(reason: "Replaced by users")
  group_admins: [ID!]!
  latest_message: ConversationMessage
  last_message: String @deprecated(reason: "Replaced by latest_message")
  last_message_timestamp: Int @deprecated(reason: "Replaced by latest_message")
  message_count: Int!
  unread_message_count: Int!
  unread_messages: Int! @deprecated(reason: "Replaced by unread_message_count")
  is_group: Boolean! @deprecated(reason: "Replaced by conversation_type")
  conversation_type: ConversationType!

# Whether the current user can send new messages to this conversation
  is_read_only: Boolean!
  created_timestamp: Int!
  organization_id: ID!
  organization_name: String!
  inbox_status: FeatureStatus!
}

input ConversationInput {
  conversation_type: ConversationType
  target: MessageTargetInput
  name: String
  image: FileUpload

# User IDs of group admins
  group_admins: [ID!]
}

type ConversationUpdate {
  conversation: Conversation!
  message_sequence_up_to: ID!
  users: [UserProfile!]!
  has_more: Boolean!
  messages: [ConversationMessage!]!
  deleted_messages: [ID!]!
  timeline: [TimelineEntry!]!
  notes: [Note!]!
}

# Conversation item pagination wrapper
type ConversationItemPagination {
# The number of available elements
  total: Int!

# List of conversation items
  data: [ConversationItem!]!
}

union ConversationItem = ConversationMessage | TimelineEntry | Note

type ConversationMessage {
  message_id: ID!
  organization_id: ID!
  conversation_id: ID!
  user_id: ID!
  message: String
  plaintext: String!
  is_read: Boolean
  timestamp: Int!
  user_reactions: [ConversationMessageReaction!]!
  attachments: Attachments!
}

type ConversationMessageReaction {
  reaction: String!
  user_id: [ID!]!
}

type UserProfilePagination {
  total: Int!
  data: [UserProfile!]!
}

input MessageTargetInput {
  member_id: [ID!]
  user_id: [ID!]
}

input MessageFromInput {
  user_id: ID
  location_id: ID
}

# Order of the conversations
enum ConversationOrder {
# Sort by a conversation sequence number ASC
  CONVERSATION_SEQUENCE_ASC

# Sort by a conversation sequence number DESC
  CONVERSATION_SEQUENCE_DESC

# Sort by a conversation sequence number ASC
  LATEST_MESSAGE_ASC

# Sort by a conversation sequence number DESC
  LATEST_MESSAGE_DESC

# Sort by a conversation name ASC
  NAME_ASC

# Sort by a conversation name DESC
  NAME_DESC

# Sort by the number of users ASC
  USER_COUNT_ASC

# Sort by the number of users DESC
  USER_COUNT_DESC
}

enum ConversationItemOrder {
  CREATED_TIMESTAMP_ASC
  CREATED_TIMESTAMP_DESC
}

type MobileAppCheckResponse {
  message: String
  message_screen: MobileAppCheckScreen
  message_title: String
  message_canvas_url: String
  message_dismissible: Boolean
  message_link_to: String
  message_link_text: String
  message_do_not_repeat_until: Int
  should_authenticate: Boolean
  should_select_organization: Boolean
  should_select_location: Boolean
}

type HomeScreenDescription {
  location: Location!
  organization: Organization!
  groups: [ContentGroup]!
}

type ContentGroup {
  pinned: Boolean
  sections: [ContentGroupSection]
}

interface ContentGroupSection {
  link_text: String
  link_target: String
  pinned: Boolean
  title: String
  description: String
  items: [ContentGroupItem]!
}

type ContentGroupSectionActions implements ContentGroupSection {
  link_text: String
  link_target: String
  pinned: Boolean
  title: String
  description: String
  items: [ContentGroupItemAction]!
}

type ContentGroupSectionBookings implements ContentGroupSection {
  link_text: String
  link_target: String
  pinned: Boolean
  title: String
  description: String
  items: [ContentGroupItemBooking]!
}

type ContentGroupSectionAvailability implements ContentGroupSection {
  link_text: String
  link_target: String
  pinned: Boolean
  title: String
  description: String
  items: [ContentGroupItemAvailability]!
}

type ContentGroupSectionArticles implements ContentGroupSection {
  link_text: String
  link_target: String
  pinned: Boolean
  title: String
  description: String
  items: [ContentGroupItemArticle]!
}

type ContentGroupSectionList implements ContentGroupSection {
  link_text: String
  link_target: String
  pinned: Boolean
  title: String
  description: String
  items: [ContentGroupItemArticle]!
}

type ContentGroupSectionCanvases implements ContentGroupSection {
  link_text: String
  link_target: String
  pinned: Boolean
  title: String
  description: String

# Height of all canvases
  height: Int
  items: [ContentGroupItemCanvas]!
}

type ContentGroupSectionProducts implements ContentGroupSection {
  link_text: String
  link_target: String
  pinned: Boolean
  title: String
  description: String
  items: [ContentGroupItemProductCollection]!
}

type ContentGroupSectionPasses implements ContentGroupSection {
  link_text: String
  link_target: String
  pinned: Boolean
  title: String
  description: String
  items: [ContentGroupItemPass]!
}

type ContentGroupSectionPlanTemplates implements ContentGroupSection {
  link_text: String
  link_target: String
  pinned: Boolean
  title: String
  description: String
  items: [ContentGroupItemPlanTemplate]!
}

interface ContentGroupItem {
  title: String
}

type ContentGroupItemAction implements ContentGroupItem {
  title: String
  image: String
  type: ContentGroupItemActionTypes!
  link_target: String
}

type ContentGroupItemBooking implements ContentGroupItem {
  title: String
  booking: Booking @deprecated(reason: "Replaced by booking_set_element")
  booking_set_element: BookingSetElement
}

type ContentGroupItemAvailability implements ContentGroupItem {
  title: String
  resource: Resource @deprecated(reason: "Replaced by resource_availability")
  availability: TimeInterval @deprecated(reason: "Replaced by resource_availability")
  resource_availability: ResourceAvailability
}

type ContentGroupItemArticle implements ContentGroupItem {
  title: String
  description: String
  url: String
  image: String
  link_target: String
}

type ContentGroupItemCanvas implements ContentGroupItem {
  title: String
  description: String
  canvas: AppCanvas
}

type ContentGroupItemProductCollection implements ContentGroupItem {
  title: String
  product_collection: ProductCollection
}

type ContentGroupItemPass implements ContentGroupItem {
  title: String
  product: Product
}

type ContentGroupItemPlanTemplate implements ContentGroupItem {
  title: String
  plan_template: PlanTemplate
}

enum ContentGroupItemActionTypes {
  CHECK_IN

# Deprecated
  BOOK_ROOM

# Deprecated
  BOOK_DESK

# Available if Exchange is connected
  BOOK_MEETING
  RESOURCE_LIST
  RESOURCE_TYPE_LIST
  LINK
  PRODUCTS
  CANVAS
}

enum MobileAppPlatform {
  IOS
  ANDROID
}

enum MobileAppCheckScreen {
  ORG_GENERIC
  UPDATE_APP
  WEBPAGE
}

type MobileAppSettings {
  app_config_id: ID
  is_white_labeled: Boolean!
  is_group: Boolean!
  is_editable: Boolean!
  is_released: Boolean!
  status: MobileAppStatus!
  app_store_url: String
  google_play_url: String
  design: MobileAppDesignSettings!
  authorization: MobileAppAuthorizationSettings!
  pending_design: MobileAppDesignSettings
  pending_authorization: MobileAppAuthorizationSettings
  notification_phone: String
  app_name: String @deprecated
  store_name: String @deprecated
  store_description: String @deprecated
  icon_url: String @deprecated
  logo_url: String @deprecated
}

type MobileAppDetails {
  is_white_labeled: Boolean!
  is_group: Boolean!
  app_store_url: String
  google_play_url: String
  brand_color: String
  maximize_brand_color: Boolean!
  app_name: String
  apple_bundle_id: String
  android_package_name: String
}

enum MobileAppStatus {
  DESIGN
  AUTHORIZATION
  AUTHORIZATION_DOCS_REVIEW
  AUTHORIZATION_DOCS_PROBLEM
  IN_DEVELOPMENT
  REVIEW_PENDING
  REVIEW_REJECTED
  REVIEW_APPROVED
  PUBLISHED
}

type MobileAppDesignSettings {
  brand_color: String
  maximize_brand_color: Boolean!
  app_name: String
  app_icon: FileData
  app_icon_cropped: FileData
  splash: FileData
  app_store_name: String
  backup_app_store_name: String
  app_store_description_short: String
  app_store_description: String
  organization_address: String
  is_expedited: Boolean!
  optix_plan: String
  build_with_kisi: Boolean!
  learn_more_about_kisi: Boolean!
}

input MobileAppDesignSettingsInput {
  brand_color: String
  maximize_brand_color: Boolean
  app_name: String
  app_icon: FileUpload
  app_icon_cropped: FileUpload
  splash: FileUpload
  app_store_name: String
  backup_app_store_name: String
  app_store_description_short: String
  app_store_description: String
  organization_address: String
  is_expedited: Boolean
  optix_plan: String
  build_with_kisi: Boolean
  learn_more_about_kisi: Boolean
}

type MobileAppAuthorizationSettings {
  authorization_letter: FileData
  apple_developer_account: String
  access_provided: Boolean!
  dba_document: FileData
}

input MobileAppAuthorizationSettingsInput {
  authorization_letter: FileUpload
  apple_developer_account: String
  access_provided: Boolean
  dba_document: FileUpload
}

type Note {
  note_id: ID!
  note: String!
  attachments: Attachments!
  created_by_user: User!
  created_timestamp: Int!
  deleted_timestamp: Int
}

input NoteInput {
# HTML content of a note
  note: String

# Note attachments
  attachments: [AttachmentInput!]
}

type NotificationSettings {
  type: String!
  group: String
  channels: [NotificationChannel!]!
  name: String!
  delay_in_seconds: Int!
}

input NotificationSettingsInput {
  type: String!
  channels: [NotificationChannel!]!
  delay_in_seconds: Int = 0
}

enum NotificationChannel {
# Send an activity notification
  ACTIVITY

# Send a push notification if a mobile device is found; otherwise, send an email
  AUTOMATIC @deprecated(reason: "Please use EMAIL and PUSH channels instead")

# Send an email
  EMAIL

# Send a push notification
  PUSH
}

type OptixBilling {
# Sign up timestamp
  signed_up_timestamp: Int

# Whether the organization has subscribed to a paid membership
  has_signed_up: Boolean
  has_dedicated_success_manager: Boolean
  has_white_labeled_mobile_app: Boolean
  has_optix_brand_removal: Boolean
  current_plan_name: String
  current_plan_frequency: PlanFrequency
  restriction_overrides: OptixBillingRestrictionOverrides
  discount_quote: String
}

type OptixBillingPlan {
  name: String!
  is_available: Boolean!
  unavailability_reasons: [String!]!
}

type OptixBillingAudit {
  audit_id: ID!
}

type OptixBillingRestrictionOverrides {
  location_cap: Int
  user_cap: Int
  enable_custom_unit: Boolean
  enable_issues: Boolean
  enable_products: Boolean
  enable_tasks: Boolean
  events: Boolean
  perks: Boolean
  visitor_management: Boolean
  add_locations: Boolean
  develop_apps: Boolean
  order_additional_onboarding_sessions: Boolean
  order_optix_brand_removal: Boolean
  order_white_labeled_mobile_app: Boolean
  send_push_notifications: Boolean
  use_announcements: Boolean
  use_properties: Boolean
}

type AppPrice {
# Monthly app price
  price_month: Float!

# Whether the price is for each location
  is_price_per_location: Boolean!

# Free trial length
  free_trial_days: Int!
}

type FeaturePrice {
# Monthly feature price
  price_month: Float!

# Free trial length
  free_trial_days: Int!
}

type Organization {
# Organization ID
  organization_id: ID!

# UUID of this organization
  organization_uuid: String!

# Name of the organization
  name: String!
  is_active: Boolean!

# Square logo
  square_logo: FileData!
  logo: String @deprecated(reason: "Replaced by square_logo")

# Wide logo
  wide_logo: FileData!

# Country
  country: String

# State/province
  region: String

# City
  city: String

# Neighborhood
  neighborhood: String

# Postal/ZIP code
  postcode: String

# Street address
  address: String

# Street address line 2
  address2: String

# Unit
  unit: String

# Lists all locations associated with one app at one specific organization
  locations(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: LocationOrder

# Returns visible locations
    include_visible: Boolean

# Returns deleted locations
    include_deleted: Boolean

# Returns hidden locations
    include_hidden: Boolean

# Filter by location ID
    location_id: [ID!]
  ): LocationPagination!

# Timezone (e.g. "America/Vancouver")
  timezone: String

# Locale (e.g. "en_CA")
  locale: String
  override_billing_address: Boolean!
  billing: InvoiceBillingDetails

# ISO 4217 currency code (e.g. "CAD")
  currency: String

# The currency symbol formatted in organization's locale
  currency_symbol: String

# The organization currency Unit
  currency_unit: Unit

# All units used at the organization
  units: [Unit!]!

# Default account invoicing date
  next_invoicing_timestamp: Int
  payment_instructions: String

# The connected payment gateway
  payment_gateway: OrganizationPaymentGateway

# The connected calendar provider (for admins only)
  calendar: OrganizationCalendar
  skype_for_business: OrganizationSkypeForBusiness
  kisi: OrganizationKisi

# Sign-in settings
  sign_in: SignInSettings
  billing_date: Int
  has_editable_billing_date: Boolean!

# Exclusive tax rate (e.g. 5 for 5%)
  exclusive_tax_rate: Float!
  tax_rate: Float @deprecated(reason: "Replaced by exclusive_tax_rate")

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float!
  plans(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Filter by plan name
    name: String
  ): PlanPagination! @deprecated

# Subdomain used at *.optixapp.com
  subdomain: String

# A fully qualified domain name
  domain: String

# How many days an invoice will show the status "Due" before changing to "Overdue"
  days_to_overdue: Int! @deprecated

# Theme
  theme: Theme

# Mobile app settings (for admins only)
  mobile_app(use_unreleased: Boolean = false): MobileAppSettings

# Public mobile app details
  mobile_app_details: MobileAppDetails
  app_links(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: AppLinkOrder = NAME_ASC

# Filter by app link name
    name: String

# Filter by app link position
    position: [AppLinkPosition!]

# Filter by app link visibility
    is_visible: Boolean
  ): AppLinkPagination!

# Optix billing details
  optix_billing: OptixBilling

# Drop-in booking widget settings
  dropin_booking_widget: DropinBookingWidget

# Sign-up widget settings
  signup_widget: SignupWidget

# Tour widget settings
  tour_widget: TourWidget

# Transaction fees for different payment method types
  transaction_fees: [TransactionFeeSettings!]!

# General contact email
  contact_email: String

# General emails are from
  contact: Contact!

# Features enabled for the organization
  features: FeatureSettings!

# Custom terms of service agreement
  terms: OrganizationTerms

# Auto-generated appendix listing the collected user properties
  terms_appendix: String
  full_terms: String

# Lists all labels associated with the organization
  labels(
# Object type
    type: LabelType
  ): [Label]!

# Lists all tags associated with the organization
  tags: [Tag]!
  resource_types: [ResourceType!]!

# List of admins (for admins only)
  admins: [Admin!]
  distance: String
  property_groups: [PropertyGroup!]!
}

input OrganizationInput {
  name: String
  square_logo: FileUpload
  wide_logo: FileUpload
  country: String
  region: String
  city: String
  neighborhood: String
  postcode: String
  address: String
  address2: String
  unit: String
  dropin_booking_widget: DropinBookingWidgetInput
  signup_widget: SignupWidgetInput
  tour_widget: TourWidgetInput
  contact_email: String
  contact_user_id: ID
  admins: [AdminInput!]
  override_billing_address: Boolean
  billing_address: String
  billing_unit: String
  billing_city: String
  billing_region: String
  billing_postcode: String
  billing_country: String
  billing_tax_number: String
  payment_instructions: String
  billing_date: Int

# Exclusive tax rate (e.g. 5 for 5%)
  exclusive_tax_rate: Float

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float
  transaction_fees: [TransactionFeeSettingsInput!]
}

type DropinBookingWidget {
  title: String
  cancellation_policy: String
  within_service_hours: Boolean
}

input DropinBookingWidgetInput {
  title: String
  cancellation_policy: String
  within_service_hours: Boolean
}

type SignupWidget {
  images: [FileData!]!
  welcome_text: String
  thank_you_text: String
  choose_plan_first: Boolean!
}

input SignupWidgetInput {
  images: [FileUpload!]
  welcome_text: String
  thank_you_text: String
  choose_plan_first: Boolean
}

type TourWidget {
  title: String
  duration_sec: Int
  min_advance_sec: Int
  max_advance_sec: Int
}

input TourWidgetInput {
  title: String
  duration_sec: Int
  min_advance_sec: Int
  max_advance_sec: Int
}

type OrganizationSkypeForBusiness {
  is_connected: Boolean!
}

type OrganizationKisi {
  is_connected: Boolean!
}

type SignInSettings {
  email: Boolean!
  social: Boolean!
  sso: SSOAuthDetails
}

type SSOAuthDetails {
  url: String!
  use_android_safe_browser: Boolean!
}

type Contact {
# Name
  name: String
  fullname: String @deprecated(reason: "Replaced by name")

# Profile image
  image: String!
  picture: String! @deprecated(reason: "Replaced by image")

# Email address
  email: String!

# User ID
  user_id: ID
}

type Theme {
# Background color
  background_color: String

# Dark mode
  dark_mode: Boolean

# Accent color
  accent_color: String

# Color on accent
  color_on_accent: String

# Navigation bar color
  nav_bar_color: String

# Color on navigation bar
  color_on_nav_bar: String

# Navigation bar shadow
  nav_bar_shadow: Int

# Font family
  font_family: String

# Form input style
  form_input_style: String

# Button corner radius
  button_corner_radius: String

# Raised buttons
  raised_buttons: Boolean
}

# Set of images
type ImageSet {
# Indicates whether there is an image
  has_image: Boolean!

# Thumb size image, regular dpi (1 dppx)
  thumb: String

# Thumb size image, double dpi
  thumb_2x: String

# Thumb large image, regular dpi (1 dppx)
  large: String

# Thumb large image, double dpi
  large_2x: String

# Thumb extra large image, regular dpi (1 dppx)
  xlarge: String

# Thumb extra large image, double dpi
  xlarge_2x: String

# Round image, regular dpi (1 dppx)
  round: String

# Round image, double dpi
  round_2x: String
  original: String @deprecated
}

type OrganizationTerms {
  value: String!
  version: Int!
  timestamp: Int!
}

type Admin {
  user: User!
  admin_role: AdminRole!
  is_temporary: Boolean!
  locations: [Location!]!
  admin_account_panel_settings: AdminAccountPanelSettings
}

input AdminInput {
  user_id: ID!
  admin_role: AdminRole!
  locations: [ID!]!
}

enum AdminRole {
  OWNER
  MANAGER
  CLIENT_SERVICE
  RECEPTION
}

# Organization pagination wrapper
type OrganizationPagination {
# The number of available elements
  total: Int!

# List of organizations
  data: [Organization!]!
}

# Transaction fees automatically added to invoices
type TransactionFeeSettings {
  method: String!
  name: String!
  is_enabled: Boolean!
  percentage_fee: Float
  additional_flat_fee: Float
  exclusive_tax_rate: Float
  inclusive_tax_rate: Float
  maximum_fee: Float
}

input TransactionFeeSettingsInput {
  method: String!
  percentage_fee: Float
  additional_flat_fee: Float
  exclusive_tax_rate: Float
  inclusive_tax_rate: Float
  maximum_fee: Float
}

type OrganizationPaymentGateway {
  is_connected: Boolean!
  account_id: String
  publishable_key: String
  name: String
  account_name: String
  account_email: String
  enabled_payment_methods: [GatewayPaymentMethod!] @deprecated(reason: "Consider using retainable_payment_methods")
  enabled_checkout_methods: [String!]
  retainable_payment_methods: [String!]
}

enum GatewayPaymentMethod {
# A debit or credit card
  CARD

# A bank account
  BANK
}

# Payment method configuration
type PaymentMethodConfiguration {
# Code used to handle a credit card in client-side apps
  secret: String
}

# Payment method details
input PaymentMethodInput {
# Payment method code (Stripe only)
  payment_method: String

# Payment method setup intent code (Stripe only)
  setup_intent: String
}

# Payment method
type PaymentMethod {
# Payment method ID
  id: ID

# Type of payment method (e.g. card, bank_account, etc.)
  type: String!

# Bank account type (e.g. Checking)
  bank_account_type: String

# Bank account display digits
  bank_account_display_digits: String

# Card last four digits
  card_last_four_digits: String

# Card expiry month (e.g. 12 for December)
  card_exp_month: Int

# Card expiry year (e.g. 2019)
  card_exp_year: Int

# Card brand (e.g. Visa, MasterCard, etc.)
  card_brand: String

# Card funding (credit, debit, prepaid, or unknown)
  card_funding: String

# Card country (e.g. country)
  card_country: String
}

type RetainablePaymentMethodOption {
  name: String!
  payment_method_type: String!
  url: String
  open_using_external_app: Boolean!
  show_native_button: Boolean!
}

type StripePaymentMethodsPagination {
  search_after: String
  payment_methods: [StripeImportablePaymentMethod]!
}

type StripeImportablePaymentMethod {
  import_id: String!
  stripe_customer_id: String!
  stripe_customer_name: String
  stripe_customer_email: String
  stripe_payment_method_id: ID!
  payment_method: String!
  optix_account: Account
  import_to_options: [Account!]!
  import_status: String!
}

type StripePaymentMethodImported {
  payment_method: PaymentMethod!
  account: Account!
}

# Stripe payment method reference to be imported
input StripePaymentMethodImportInput {
  stripe_customer_id: ID!
  stripe_payment_method_id: ID!
  account_id: ID
  account_email: String
  account_name: String
  mandate: String
}

input PaymentInput {
# The way the charge is invoiced (for admins only)
  charge: PaymentChargeMode

# Due date for the invoice (for charge=DATE)
  invoice_due_timestamp: Int

# Optional payment method (for charge=NOW)
  pm_id: ID
}

input BookingPaymentInput {
# The way the payment is calculated
  calculate: PaymentCalculateMode = BEST_ALLOWANCE_NOW

# The way the charge is invoiced (for admins only). User bookings respect the invoice policy for additional charges.
  charge: PaymentChargeMode = FOLLOWING_BILLING_DATE

# Deprecated; allowances to be used (for calculate=FIXED_ALLOWANCE)
  allowance_usage: [AllowanceUsageInput!]

# Optional payment method (for charge=NOW)
  pm_id: ID

# Override of the price before tax (for admins only)
  price_override: Float
}

enum PaymentCalculateMode {
# Use the specified allowance
  FIXED_ALLOWANCE @deprecated(reason: "The current best allowance will be used")

# Automatically choose the best allowance available now
  BEST_ALLOWANCE_NOW

# Automatically choose the best allowance available at the end (e.g. when a booking ends)
  BEST_ALLOWANCE_AT_END

# Ignore the available allowances
  NO_ALLOWANCE
}

enum PaymentChargeMode {
# Invoice the items and collect the payment now
  NOW

# Invoice the items due today
  TODAY

# Invoice the items at the end (e.g. when a booking ends)
  AT_END

# Add the items to the following pending invoice
  FOLLOWING_BILLING_DATE

# Invoice the items due on the given date
  DATE
}

input CancellationPolicyInput {
# Credit back any unused charges
  credit_unused_time: Boolean

# Return the deposit
  credit_deposit_amount: Float
}

type Payment {
  account: Account!

# Item quantity
  quantity: Float!

# The item unit amount
  unit_amount: Float!

# The item unit amount without a discount applied
  unit_amount_without_discount: Float!

# Price description (e.g. "$5.00/hour", "CA$10.00/day", etc.)
  price_description: String!

# Conditional pricing name, NULL if the default pricing was applied
  resource_conditional_pricing_name: String

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float!

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float!

# Tax
  tax: Float!

# Included tax
  included_tax: Float!

# The total cost of the item including tax
  total: Float!
  accesses: [WalletAccessUsage!]!
  allowance_unit: Unit

# Allowance available before the payment
  allowance_available: Float

# Allowance used for this payment
  allowance_used: Float

# Allowance remaining for this payment
  allowance_remaining: Float

# Description of allowance available before the payment
  allowance_available_description: String

# Description of allowance used for this payment
  allowance_used_description: String

# Description of allowance remaining for this payment
  allowance_remaining_description: String

# Unlimited allowance in effect
  unlimited_allowance: Boolean!
  discount_pct: Float
}

type PlanTemplate {
  plan_template_id: ID!
  name: String!
  description: String!
  terms: String
  image: FileData
  appearance: String
  allowance_renewal_frequency: PlanFrequency!
  price: Float!
  price_frequency: PlanFrequency!
  deposit: Float!
  set_up_fee: Float!

# Override the default invoicing settings
  override_tax_rate: Boolean!

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float

# Override the default invoicing settings
  override_inclusive_tax_rate: Boolean!

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float

# Free trial length
  free_trial_days: Int

# Start billing cycle (for plans without a free trial)
  start_billing_on: PlanBillingStart!

# Invoice deposit, setup fee, and any prorated charges
  initial_invoice_due: PlanInitialInvoice!
  default_end_date: PlanEndDate!
  default_end_date_days: Int
  onboarding_enabled: Boolean!
  non_onboarding_enabled: Boolean!
  promote: Boolean!
  accesses: [Access!]!

# Whether the plan template is available in all locations
  in_all_locations: Boolean!

# Locations where the plan template is available
  locations: [Location!]!

# Custom order position
  order: Int
}

type PlanTemplatePagination {
# The number of available elements
  total: Int!

# If nothing found, try without the location filter applied
  found_in_all_locations: Boolean!
  total_in_all_locations: Int! @deprecated(reason: "Replaced by found_in_all_locations")

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of plans
  data: [PlanTemplate]!
}

enum PlanFrequency {
  DAILY
  WEEKLY
  BIWEEKLY
  THIRTY_DAYS
  SIXTY_DAYS
  NINETY_DAYS
  MONTHLY
  QUARTERLY
  BIANNUAL
  ANNUAL
  UNKNOWN
}

enum PlanBillingStart {
  FOLLOWING_BILLING_DATE
  PLAN_START
}

enum PlanInitialInvoice {
  FOLLOWING_BILLING_DATE
  ANCHOR
  PLAN_START
  PLAN_PURCHASE
}

enum PlanEndDate {
  NEVER
  USER_CAN_CHOOSE
  FIXED
}

input PlanTemplateInput {
  name: String
  description: String
  terms: String
  appearance: String
  allowance_renewal_frequency: PlanFrequency
  price: Float
  price_frequency: PlanFrequency
  deposit: Float
  set_up_fee: Float

# Override the default invoicing settings
  override_tax_rate: Boolean

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float

# Override the default invoicing settings
  override_inclusive_tax_rate: Boolean

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float

# Free trial length
  free_trial_days: Float

# Start billing cycle (for plans without a free trial)
  start_billing_on: PlanBillingStart

# Invoice deposit, setup fee, and any prorated charges
  initial_invoice_due: PlanInitialInvoice
  default_end_date: PlanEndDate
  default_end_date_days: Float
  onboarding_enabled: Boolean
  non_onboarding_enabled: Boolean
  promote: Boolean
  accesses: [AccessInput!]
  in_all_locations: Boolean = true
  location_id: [ID!]
}

enum UserVisibility {
  ADMINS_ONLY
  EVERYONE
  EXISTING_USERS
  NEW_USERS
}

type Price {
  unit: Unit!
  price: Float
  price_max: Float
}

input PriceInput {
  unit_id: ID!
  price: Float
  price_max: Float
  set_no_price: Boolean
  set_no_price_max: Boolean
}

type Unit {
  unit_id: ID!
  name: String!
  name_plural: String!
  type: UnitType!
  currency_symbol: String
}

enum UnitType {
  CURRENCY
  CUSTOM
  HOURS
  USES
  UNKNOWN
}

type ConditionalPricing {
  conditional_pricing_id: ID!
  prices: [Price!]!
  condition: EvaluableCondition!
  name: String!
  order: Int!
  override_tax_rate: Boolean!
  tax_rate: Float
  override_inclusive_tax_rate: Boolean!
  inclusive_tax_rate: Float
}

input ConditionalPricingInput {
  conditional_pricing_id: ID
  prices: [PriceInput!]!
  condition: EvaluableConditionInput!
  name: String!
  order: Int!
  override_tax_rate: Boolean
  tax_rate: Float
  override_inclusive_tax_rate: Boolean
  inclusive_tax_rate: Float
}

# Product collection
type ProductCollection {
# Collection unique ID
  product_collection_id: ID!

# Collection name
  name: String!

# Collection description
  description: String!

# Collection image
  image: FileData

# Indicates whether the collection is public
  is_public: Boolean!

# Indicates whether the collection is visible on the mobile app homescreen
  is_on_app: Boolean!

# Whether the collection is available in all locations
  in_all_locations: Boolean!

# Locations in which the collection will be visible
  locations: [Location!]!

# Rule for the tags that the products must match in order to be included
  include_tags_rule: IncludeProductTagsRule!

# Tags used to include the products
  include_tags: [String!]!

# Tags used to group the included products
  group_tags: [String!]!

# Date created
  created_timestamp: Int!

# The number of products
  product_count: Int!

# The grouped products
  product_groups: [ProductGroup!]!

# The type of products this collection supports
  type: ProductType!
}

# Product collection pagination wrapper
type ProductCollectionPagination {
# The number of available elements
  total: Int!

# If nothing found, try without the location filter applied
  found_in_all_locations: Boolean!
  total_in_all_locations: Int! @deprecated(reason: "Replaced by found_in_all_locations")

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of product collections
  data: [ProductCollection]!
}

enum ProductCollectionOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC

# Sort by creation date ASC
  CREATED_TIMESTAMP_ASC

# Sort by creation date DESC
  CREATED_TIMESTAMP_DESC
}

enum IncludeProductTagsRule {
# Include the products matching at least one tag
  ANY

# Include the products matching all tags
  ALL
}

type ProductGroup {
  name: String!
  products: [Product!]!
}

# Product sale
type ProductSale {
# Product sale unique ID
  product_sale_id: ID!
  product: Product!

# Account charged for the sale
  account: Account!

# The user who made this purchase
  created_by_user: User

# Location associated with this sale
  location: Location

# Sale number
  number: String

# Invoice item name
  name: String!

# Invoice item description
  description: String!

# Number of products
  quantity: Int!

# Invoice item quantity
  invoice_item_quantity: Float!

# The item unit amount
  unit_amount: Float!

# Exclusive tax rate (e.g. 5 for 5%, max: 99.9999)
  tax_rate: Float!

# Inclusive tax rate (e.g. 5 for 5%, max: 99.9999)
  inclusive_tax_rate: Float!

# Tax
  tax: Float!

# The total cost of the item including tax
  total: Float!

# Notes
  notes: String

# Sale generation date
  created_timestamp: Int!

# Whether this sale has been canceled
  is_canceled: Boolean!

# Status of the payment
  invoice_status: InvoiceStatus!

# ID of the finalized invoice containing the payment
  invoice_id: ID

# Number of the finalized invoice containing the payment
  invoice_number: String

# Information about the charges and wallet access usage
  payment: Payment

# Invoices related to this sale
  invoices: [Invoice!]!

# Invoice items related to this sale
  invoice_items: [PendingInvoiceItem!]!

# Attached labels
  labels: [Label!]!

# Expiration timestamp (for passes)
  expiration_timestamp: Int

# Access usage user (for passes)
  access_usage_user: User

# Whether there is any allowance left (for passes)
  has_allowance_left: Boolean
}

# Product sales pagination wrapper
type ProductSalePagination {
# The number of available elements
  total: Int!

# If nothing found, try without the location filter applied
  found_in_all_locations: Boolean!
  total_in_all_locations: Int! @deprecated(reason: "Replaced by found_in_all_locations")

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of product sales
  data: [ProductSale]!
}

enum ProductSaleOrder {
# Sort by number ASC
  NUMBER_ASC

# Sort by number DESC
  NUMBER_DESC

# Sort by description ASC
  DESCRIPTION_ASC

# Sort by description DESC
  DESCRIPTION_DESC

# Sort by number of products ASC
  QUANTITY_ASC

# Sort by number of products DESC
  QUANTITY_DESC

# Sort by item quantity ASC
  INVOICE_ITEM_QUANTITY_ASC

# Sort by item quantity DESC
  INVOICE_ITEM_QUANTITY_DESC

# Sort by user name ASC
  USER_ASC

# Sort by user name DESC
  USER_DESC

# Sort by product name ASC
  NAME_ASC

# Sort by product name DESC
  NAME_DESC

# Sort by date ASC
  CREATED_TIMESTAMP_ASC

# Sort by date DESC
  CREATED_TIMESTAMP_DESC

# Sort by total ASC
  TOTAL_ASC

# Sort by total DESC
  TOTAL_DESC
}

input ProductSaleInput {
# Product ID
  product_id: ID

# Associated account
  account: AccountInput
  access_usage_user_id: ID

# Location ID
  location_id: ID

# Add the charge to the invoice (only for admins)
  invoice_id: ID

# Expected invoicing time of the pending invoice (only for admins)
  expected_invoicing_timestamp: Int

# Number of products
  quantity: Int

# Invoice item (for admins only)
  invoice_item: InvoiceItemInput
  use_allowance: Boolean = true

# Notes
  notes: String

# Sale labels (for admins only)
  label_id: [ID!]
}

input ProductSaleSearchInput {
  location_id: [ID!]
  product_name: String
  product_tags: [String!]
  label_id: [ID!]
  account_id: ID
  account_name: String
  search: String
  invoice_status: [InvoiceStatus!]
  created_timestamp_from: Int
  created_timestamp_to: Int
  include_canceled: Boolean
  type: [ProductType!] = [REGULAR]
  has_allowance_left: Boolean
}

type ProductSaleChange {
  product_sale: ProductSale!
  available_payments: [Payment!]!
  payment: Payment
  invoices: [ChangeInvoice!]!
}

# Product
type Product {
# Product unique ID
  product_id: ID!

# Product name
  name: String!

# Product description
  description: String!

# Terms (for passes)
  terms: String

# Product image
  image: FileData

# Appearance (for passes)
  appearance: String

# Indicates whether the regular product is available
  is_available: Boolean! @deprecated(reason: "Replaced by non_onboarding_enabled")

# Indicates whether the product is available for new users
  onboarding_enabled: Boolean!

# Indicates whether the product is available for the existing users
  non_onboarding_enabled: Boolean!

# Promote product
  promote: Boolean!

# Indicates whether the product is deleted
  is_deleted: Boolean!

# Price for each unit of this product
  unit_amount: Float!

# Prices in all units available
  prices: [Price!]!

# Override the default invoicing settings
  override_tax_rate: Boolean!

# Exclusive tax rate (e.g. 5 for 5%, max: 99.9999)
  tax_rate: Float!
  no_tax_rate: Boolean!

# Override the default invoicing settings
  override_inclusive_tax_rate: Boolean!

# Inclusive tax rate (e.g. 5 for 5%, max: 99.9999)
  inclusive_tax_rate: Float!
  no_inclusive_tax_rate: Boolean!

# Product type
  type: ProductType!

# Accesses (for passes)
  accesses: [Access!]!

# Expiration time (for passes)
  allowance_expire_days: Int!

# Date created
  created_timestamp: Int!

# Whether the product is available in all locations
  in_all_locations: Boolean!

# Locations where the product is available
  locations: [Location!]!

# Product labels
  labels: [Label!]!

# Product tags
  tags: [String!]!

# Custom order position
  order: Int
}

enum ProductOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC

# Sort by unit amount ASC
  UNIT_AMOUNT_ASC

# Sort by unit amount DESC
  UNIT_AMOUNT_DESC

# Sort by availability ASC
  IS_AVAILABLE_ASC @deprecated

# Sort by availability DESC
  IS_AVAILABLE_DESC @deprecated

# Sort by availability for new users ASC
  ONBOARDING_ENABLED_ASC

# Sort by availability for new users DESC
  ONBOARDING_ENABLED_DESC

# Sort by availability for the existing users ASC
  NON_ONBOARDING_ENABLED_ASC

# Sort by availability for the existing users DESC
  NON_ONBOARDING_ENABLED_DESC
}

# Product pagination wrapper
type ProductPagination {
# The number of available elements
  total: Int!

# If nothing found, try without the location filter applied
  found_in_all_locations: Boolean!
  total_in_all_locations: Int! @deprecated(reason: "Replaced by found_in_all_locations")

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of products
  data: [Product]!
}

enum ProductType {
  PASS
  REGULAR
}

enum PropertyOrder {
  PREDEFINED_ORDER
  NAME_ASC
  NAME_DESC
}

# Properties pagination wrapper
type PropertyPagination {
# The number of available elements
  total: Int!

# List of properties
  data: [Property!]!
}

type PropertyGroup {
# Property group ID
  property_group_id: ID!

# Group name
  name: String!

# The corresponding properties
  properties: [Property!]!
}

input PropertyGroupInput {
  name: String
}

type Property {
# Property ID
  property_id: ID!
  reference_type: PropertyReferenceType!

# Property name
  name: String!

# Reason for collecting information
  description: String

# Placeholder text
  placeholder: String

# Property input type
  input_type: PropertyInputType!

# Whether this property is visible for the users to fill out in their mobile apps or only to the admins
  users_can_write: Boolean!

# Display on public user profiles
  is_public: Boolean!

# Display during onboarding
  show_during_onboarding: Boolean!

# Display on inquiry
  inquiry_display_policy: PropertyPolicyStatus!

# Display on drop in booking
  booking_display_policy: PropertyPolicyStatus!

# Display on tour
  tour_display_policy: PropertyPolicyStatus!

# Users are required to fill out
  is_required: Boolean!

# Options for single-select and multi-select properties
  select_options: [String!]
}

input PropertyInput {
  name: String
  description: String
  placeholder: String
  input_type: PropertyInputType
  users_can_write: Boolean
  is_public: Boolean
  show_during_onboarding: Boolean
  is_required: Boolean
  select_options: [String!]
}

enum PropertyReferenceType {
  USER
  UNKNOWN
}

enum PropertyInputType {
# Text (single line)
  TEXT

# Text (multi-line)
  TEXTAREA

# Email
  EMAIL

# Phone
  PHONE

# Numerical
  NUMBER

# Date picker
  DATE

# Single option
  SELECT

# Multiple options
  MULTIPLE
  UNKNOWN
}

type PropertyValue {
  property: Property!
  value: String
}

input PropertyValueInput {
  property_id: ID!
  value: [String!]
  delete: Boolean
}

# A user public profile
type UserProfile {
# User unique ID
  user_id: ID!

# Member unique ID
  member_id: ID @deprecated

# First name
  name: String

# Last name
  surname: String

# Profile image
  image: ImageSet
  picture: ImageSet @deprecated(reason: "Replaced by image")

# Primary location
  primary_location: String

# Job title
  title: String

# Skills
  skills: [String!]

# Biography
  bio: String

# Company name
  company: String

# Phone number
  phone: String

# City
  city: String

# Linkedin profile
  linkedin: String

# Public user properties
  properties: [PublicUserProperty]!
}

type PublicUserProperty {
# Property group
  group: String!

# Property name
  name: String!

# List of values related to this property
  values: [String!]
  type: PropertyInputType!
}

# A team public profile
type TeamProfile {
# Team unique ID
  team_id: ID!

# Name
  name: String

# Primary location
  primary_location: String

# Industry
  industry: String

# Profile image
  image: ImageSet

# City
  city: String

# Profile
  profile: String

# Website
  website: String

# Twitter
  twitter: String

# Facebook
  facebook: String
}

type Recurrence {
# Recurrence rule as defined in RFC 5545 (e.g. "FREQ=WEEKLY;INTERVAL=2;BYDAY=MO,WE,FR"). It cannot contain DTSTART, the timezone of the corresponding location is used.
  rrule: String!
  parts: RecurrenceParts!

# Description (e.g. "Every other week on Monday, Wednesday and Friday, until December 31, 2030")
  description: String!

# Days of the week (e.g. "Mon-Wed, Fri")
  days_of_week: String

# Time of day (e.g. "9am - 1pm")
  time_of_day: String
  skipped_timestamps: [Int!]
}

# Recurrence that is defined by either RRULE or its parts
input RecurrenceDraftInput {
# Start timestamp for the occurrence
  start_timestamp: Int

# Time zone in TZDATA format (e.g. "America/Vancouver")
  timezone: String = "UTC"

# Recurrence rule as defined in RFC 5545 (e.g. "FREQ=WEEKLY;INTERVAL=2;BYDAY=MO,WE,FR"). It cannot contain DTSTART.
  rrule: String
  parts: RecurrencePartsInput
}

# Recurrence that is defined by either RRULE or its parts
input RecurrenceInput {
# Recurrence rule as defined in RFC 5545 (e.g. "FREQ=WEEKLY;INTERVAL=2;BYDAY=MO,WE,FR"). It cannot contain DTSTART, the timezone of the corresponding location is used.
  rrule: String
  parts: RecurrencePartsInput
}

# Recurrence that is defined by either RRULE or its parts
input BookingRecurrenceInput {
# Recurrence rule as defined in RFC 5545 (e.g. "FREQ=WEEKLY;INTERVAL=2;BYDAY=MO,WE,FR"). It cannot contain DTSTART, the timezone of the corresponding location is used.
  rrule: String
  parts: RecurrencePartsInput

# Scope of the affected occurrences when changing the bookings
  scope: RecurrenceScope = ALL

# Occurrences that should be skipped (for scope=ALL or FOLLOWING)
  skipped_timestamps: [Int!]

# Override fields for the exceptions (for scope=ALL or FOLLOWING). It may be used to resolve the conflicts.
  exceptions: [BookingRecurrenceExceptionInput!]
}

type RecurrenceParts {
  freq: RecurrenceFrequency!
  interval: Int!
  wkst: String!
  count: Int
  until: Int
  bymonth: [Int!]
  byweekno: [Int!]
  byyearday: [Int!]
  bymonthday: [Int!]
  byday: [String!]
  bysetpos: [Int!]
}

input RecurrencePartsInput {
# The type of recurrence rule
  freq: RecurrenceFrequency!

# The interval between each iteration (e.g. given DAILY frequency, 2 for "every 2 days")
  interval: Int = 1

# The week start day (e.g. MO, TU, WE, TH, FR, SA, SU)
  wkst: String = "MO"

# How many occurrences will be generated (default: unlimited)
  count: Int

# Timestamp when the recurrence should stop (default: unlimited)
  until: Int

# The months to apply the recurrence to (e.g. 1 for January, 12 for December)
  bymonth: [Int!]

# The week numbers to apply the recurrence to (from 1 to 53 or -53 to -1). Negative values mean that the counting starts from the end of the year.
  byweekno: [Int!]

# The days of the year to apply the recurrence to (from 1 to 366 or -366 to -1). Negative values mean that the counting starts from the end of the year.
  byyearday: [Int!]

# The days of the month to apply the recurrence to (from 1 to 31 or -31 to -1). Negative values mean that the counting starts from the end of the month.
  bymonthday: [Int!]

# The days of the week to apply the recurrence to (e.g. MO, TU, WE, TH, FR, SA, SU). Each day can be preceded by a number, indicating a specific occurrence within the interval (e.g. "-1MO" for "the last Monday").
  byday: [String!]

# The positions within the valid occurrences inside a frequency period (e.g. given MONTHLY frequency and [MO,TU,WE,TH,FR] byweekday, -1 for "the last work day of every month")
  bysetpos: [Int!]
}

enum RecurrenceFrequency {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

enum RecurrenceScope {
# Change all occurrences in the sequence, except for the ones in the past
  ALL

# Change only the specified occurrences, i.e. make the exceptions
  SINGLE

# Change the specified occurrence and all the following ones. This will split the recurrence into two.
  FOLLOWING
}

input BookingRecurrenceExceptionInput {
  original_start_timestamp: Int!
  booking: BookingSetElementInput!
}

type HomeScreenPrimaryActionButton {
  app_order_id: ID!
  app_link_id: ID
  name: String!
  icon: String
  is_editable: Boolean!
  is_visible: Boolean!

# Name of the app or feature that enables the button
  feature: String
}

input OrderInput {
  object_id: ID!
  order: Int!
}

enum ObjectOrder {
  CREATED_TIMESTAMP_ASC
  CREATED_TIMESTAMP_DESC
  CUSTOM
  PRICE_ASC
  PRICE_DESC
}

# Resource type group pagination wrapper
type ResourceTypeGroupPagination {
# The number of available elements
  total: Int!

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of resource type groups
  data: [ResourceTypeGroup!]!
}

# Resource type group
type ResourceTypeGroup {
# ID of the group
  resource_type_group_id: ID!
  resource_group_id: ID! @deprecated(reason: "Replaced by resource_type_group_id")

# Name of the group
  name: String!

# Resource type group description
  description: String

# Main image
  main_image: FileData

# List of images
  images: [FileData!]!

# Resource type
  type: ResourceType!
  resource_count: Int!
}

input ResourceTypeGroupInput {
# Resource type
  resource_type_id: ID

# Resource type group name
  name: String

# Resource type group description
  description: String

# Resource type group images
  images: [FileUpload!]
}

# Order of the resource type groups
enum ResourceTypeGroupOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC
}

type ResourceTypeGroupWithQuantity {
# Resource type group
  resource_type_group: ResourceTypeGroup!
  resource_group: ResourceTypeGroup! @deprecated(reason: "Replaced by resource_type_group")

# The number of resources in the group
  quantity: Int!
  capacity: Int! @deprecated(reason: "Replaced by quantity")
}

# Replaced by ResourceTypeGroup
type ResourceGroup {
  resource_group_id: ID!
  name: String!
}

# Replaced by ResourceTypeGroupWithQuantity
type ResourceGroupCapacity {
  resource_group: ResourceGroup!
  capacity: Int!
}

# Resource type pagination wrapper
type ResourceTypePagination {
# The number of available elements
  total: Int!

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of resource type
  data: [ResourceType!]!
}

# Type of a resource
type ResourceType {
# ID of the resource type
  resource_type_id: ID!
  ws_type_id: ID @deprecated

# Type name
  name: String!
  type: String! @deprecated(reason: "Replaced by name")
  booking_experience: BookingExperience!
  resource_count(location_id: [ID!]): Int!
  nonspecific_booking_group_count(location_id: [ID!]): Int

# Whether to allow the free hand mode when selecting the booking times
  time_selection_type: TimeSelectionType!

# Conditional availability based on the account type
  conditional_availability: [ConditionalResourceAvailability!]

# Whether to use custom service hours for the current user
  use_custom_service_hours: Boolean!

# Time slots or custom service hours for the current user
  time_within_week_days: [TimeWithinWeekDay!]!

# Show the resources in "Next Available" section on app home screen
  show_next_available: Boolean!

# Whether to allow the resources to be booked in a nonspecific way, e.g. book an arbitrary resource of this type
  has_nonspecific_bookings: Boolean!
  type_groups: [ResourceTypeGroup!]!
  app_links: [AppLink!]!
  is_visible: Boolean!
}

enum BookingExperience {
  GALLERY
  LIST
}

enum TimeSelectionType {
  FREE_SELECT
  TIME_SLOTS
}

input ResourceTypeInput {
# Resource type name
  name: String

# Booking experience for the users
  booking_experience: BookingExperience

# Whether to allow the free hand mode when selecting the booking times
  time_selection_type: TimeSelectionType

# Conditional availability based on the account type
  conditional_availability: [ConditionalResourceAvailabilityInput!]

# Show the resources in "Next Available" section on app home screen
  show_next_available: Boolean

# Whether to allow the resources to be booked in a non-specific way, e.g. book an arbitrary resource of this type
  has_nonspecific_bookings: Boolean
  app_link_id: [ID!]
}

type ConditionalResourceAvailability {
# Type of the account
  account_type_label: Label

# Whether to use custom service hours over the location ones (for time_selection_type=FREE_SELECT)
  use_custom_service_hours: Boolean!

# Time slots or custom service hours for the resources
  time_within_week_days: [TimeWithinWeekDay!]!
}

input ConditionalResourceAvailabilityInput {
# Type of the account
  account_type_label_id: ID

# Whether to use custom service hours over the location ones (for time_selection_type=FREE_SELECT)
  use_custom_service_hours: Boolean!

# Time slots or custom service hours for the resources
  time_within_week_days: [TimeWithinWeekDayInput!]!
}

type TimeWithinWeekDay {
# Time interval name
  name: String

# Day of the week
  day_of_week: WeekDay!

# Start time (e.g. "09:00:00")
  start_time: Time!

# End time (e.g. "11:00:00")
  end_time: Time!
  is_enabled: Boolean!
  resource_type_time_id: ID
}

input TimeWithinWeekDayInput {
# Time interval name
  name: String

# Day of the week
  day_of_week: WeekDay!

# Start time (e.g. "09:00", "09:00:00", etc.)
  start_time: Time!

# End time (e.g. "11:00", "11:00:00", etc.)
  end_time: Time!
  is_enabled: Boolean = true
}

# Order of the resource types
enum ResourceTypeOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC
}

# Resource pagination wrapper
type ResourcePagination {
# The number of available elements
  total: Int!

# If nothing found, try without the location filter applied
  found_in_all_locations: Boolean!
  total_in_all_locations: Int! @deprecated(reason: "Replaced by found_in_all_locations")

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of resources
  data: [Resource]!
}

type Resource {
# ID of the resource
  resource_id: ID!
  organization_id: ID!

# Name (e.g. "Glass room")
  name: String
  title: String @deprecated(reason: "Replaced by name")

# Description
  description: String

# Directions
  directions: String

# Location associated with this resource
  location: Location!

# Whether instant booking is enabled for this room
  instant_booking: Boolean @deprecated

# Indicates whether this resource can be booked
  is_bookable: Boolean @deprecated(reason: "Replaced by ResourceBookingPolicy")
  bookable: Boolean @deprecated(reason: "Replaced by ResourceBookingPolicy")

# Indicates whether this is a favorite resource of the current user
  is_favorite: Boolean

# Type of resource
  type: ResourceType!

# Resource type group
  type_group: ResourceTypeGroup

# Quantity of the same resource at this location
  quantity: Int @deprecated

# Maximum capacity of the resource
  capacity: Int

# Price per hour
  booking_price_hour: Float @deprecated(reason: "Replaced by prices")
  price_hour: Float @deprecated(reason: "Replaced by booking_price_hour")

# Setup fee
  setup_fee: Float @deprecated

# Price per day
  booking_price_max: Float @deprecated(reason: "Replaced by prices")
  price_day: Float @deprecated(reason: "Replaced by booking_price_max")

# Price per month
  price_month: Float @deprecated(reason: "Replaced by assignment_price_month")

# Prices in all units available
  prices: [Price!]!

# Override the default invoicing settings
  override_tax_rate: Boolean!

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float

# Override the default invoicing settings
  override_inclusive_tax_rate: Boolean!

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float
  conditional_pricing: [ConditionalPricing!]

# Assignment price per month
  assignment_price_month: Float

# Maximum booking time (in hours)
  maximum_booking: Float @deprecated(reason: "Replaced by ResourceBookingPolicy")

# Maximum booking time (in seconds)
  max_booking_duration_sec: Int @deprecated(reason: "Replaced by ResourceBookingPolicy")

# Minimum booking time (in hours)
  minimum_booking: Float @deprecated(reason: "Replaced by ResourceBookingPolicy")

# Minimum booking time (in seconds)
  min_booking_duration_sec: Int @deprecated(reason: "Replaced by ResourceBookingPolicy")

# Indicates whether this resource is public and can be booked by the user. Otherwise only the organization manager can book it.
  public: Boolean @deprecated

# Maximum days in advance that a booking can be requested (for example, 7 for seven days)
  max_future_days: Int @deprecated(reason: "Replaced by ResourceBookingPolicy")

# How much in advance a booking can be requested (in seconds)
  max_advance_booking_sec: Int @deprecated(reason: "Replaced by ResourceBookingPolicy")

# How much in advance a booking can be requested (in seconds)
  min_advance_booking_sec: Int @deprecated(reason: "Replaced by ResourceBookingPolicy")

# The minimum time before the same user can book the resource again (in seconds)
  no_return_sec: Int @deprecated(reason: "Replaced by ResourceBookingPolicy")
  no_return_minutes: Int @deprecated(reason: "Replaced by no_return_sec")

# The minimum time before users can book a resource again (in seconds)
  buffer_time_sec: Int @deprecated(reason: "Replaced by ResourceBookingPolicy")

# Allows 24 hour bookings
  fullday_booking: Boolean @deprecated(reason: "Replaced by is_bookable_outside_service_hours")

# Whether bookings at any time of the day are allowed
  is_bookable_outside_service_hours: Boolean @deprecated(reason: "Replaced by ResourceBookingPolicy")

# Booking group
  booking_group_id: ID @deprecated(reason: "Replaced by resource groups and is_booking_group")

# Booked as room or desk
  booked_as: BookingAsType! @deprecated(reason: "Replaced by resource types")

# Whether bookings of this resource can have invitees
  can_have_invitees: Boolean @deprecated(reason: "Replaced by ResourceBookingPolicy")

# Whether this resource can have amenities
  can_have_amenities: Boolean @deprecated(reason: "This flag is not used anymore")

# Whether the repeat bookings are allowed
  can_have_recurring_bookings: Boolean @deprecated(reason: "Replaced by ResourceBookingPolicy")

# Resource booking policy
  booking_policy: ResourceBookingPolicy!

# Resource size (square meters)
  size_sq_meters: Float

# Whether this resource is assignable
  is_assignable: Boolean!

# Whether this resource is available for drop-in bookings
  is_dropin_bookable: Boolean!

# Lists all bookings associated with the current resource
  bookings(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: BookingOrder

# Filter by user ID (for admins only). Use -1 to retrieve data associated with all users.
    user_id: ID

# Includes new bookings
    include_new: Boolean

# Includes approved bookings
    include_approved: Boolean

# Includes completed bookings (deprecated)
    include_completed: Boolean

# Includes canceled bookings
    include_canceled: Boolean

# Includes canceled bookings (deprecated: replaced by include_canceled)
    include_cancelled: Boolean

# Includes rejected bookings
    include_rejected: Boolean

# Only associated with specific resources
    resource_id: [ID]

# Only associated with specific locations
    location_id: [ID]

# Bookings starting after the timestamp (inclusive)
    start_timestamp_from: Int

# Bookings starting before the timestamp (inclusive)
    start_timestamp_to: Int

# Bookings ending after the timestamp (inclusive)
    end_timestamp_from: Int

# Bookings ending before the timestamp (inclusive)
    end_timestamp_to: Int

# Deprecated: use start_timestamp_from
    start_from: Int

# Deprecated: use start_timestamp_to
    start_to: Int

# Includes bookings the current user was invited to
    invited: [InviteeStatus!]
    booked_as: BookingAsType
    in_progress: Boolean
    is_hidden: Boolean
  ): BookingPagination!

# Resource main image
  main_image: FileData!
  image: ImageSet! @deprecated(reason: "Replaced by main_image and images")
  picture: ImageSet! @deprecated(reason: "Replaced by main_image and images")

# List of images
  images: [FileData!]!
  availability(
# Search parameters (default: from 1 week in the past to 1 week in the future, duration is at least 30 minutes)
    input: ResourceAvailabilityInput!
  ): [TimeInterval!]!

# Resource amenities
  amenities: [Amenity]

# Creation timestamp
  created_timestamp: Int!
  parent_resources: [Resource!]!
  child_resources: [Resource!]!
}

input ResourceInput {
# Location of the resource
  location_id: ID

# Child resources
  resource_child_id: [ID!]

# Resource type
  resource_type_id: ID

# Resource type group
  resource_type_group_id: ID

# Resource name
  name: String

# Resource description
  description: String

# Resource code
  code: String

# Resource directions
  directions: String

# Resource capacity
  capacity: Int

# Deprecated: replaced by prices
  booking_price_hour: Float

# Deprecated: replaced by prices
  booking_price_max: Float

# Prices per unit
  prices: [PriceInput!]

# Override the default invoicing settings
  override_tax_rate: Boolean

# Exclusive tax rate (e.g. 5 for 5%)
  tax_rate: Float

# Override the default invoicing settings
  override_inclusive_tax_rate: Boolean

# Inclusive tax rate (e.g. 5 for 5%)
  inclusive_tax_rate: Float
  conditional_pricing: [ConditionalPricingInput!]

# Assignment price per month
  assignment_price_month: Float

# Resource booking policy
  booking_policy: ResourceBookingPolicyInput

# Resource images
  images: [FileUpload!]

# Whether this resource is assignable
  is_assignable: Boolean

# Whether this resource is available for drop-in bookings
  is_dropin_bookable: Boolean

# Resource size (square meters)
  size_sq_meters: Float

# Amenities available at this resource
  amenities: [ID!]
}

type ResourceBookingPolicy {
# Indicates whether this resource can be booked
  is_bookable: Boolean!

# Whether this resource can be booked by admins only
  is_bookable_by_admins_only: Boolean!

# Whether bookings at any time of the day are allowed
  is_bookable_outside_service_hours: Boolean!

# Whether the repeat bookings are allowed
  can_have_repeat_bookings: Boolean!

# Whether bookings of this resource can have invitees
  can_have_invitees: Boolean!

# Minimum booking time (in seconds)
  min_booking_duration_sec: Int!

# Maximum booking time (in seconds)
  max_booking_duration_sec: Int!

# How much in advance a booking can be requested (in seconds or days, based on unit)
  min_advance_booking_time: Int

# Minimum advance time unit (seconds or days)
  min_advance_booking_unit: TimeUnit

# How much in advance a booking can be requested (in seconds or days, based on unit)
  max_advance_booking_time: Int

# Maximum advance time unit (seconds or days)
  max_advance_booking_unit: TimeUnit
  min_advance_booking_sec: Int! @deprecated(reason: "Replaced by min_advance_booking_time")
  max_advance_booking_sec: Int! @deprecated(reason: "Replaced by max_advance_booking_time")

# The minimum time before the same user can book the resource again (in seconds)
  no_return_sec: Int!

# The minimum time before users can book a resource again (in seconds)
  buffer_time_sec: Int!

# How long before the booking start time a user can cancel, or edit the times (in seconds)
  editable_before_start_sec: Int!
}

input ResourceBookingPolicyInput {
# Indicates whether this resource can be booked
  is_bookable: Boolean

# Whether this resource can be booked by admins only
  is_bookable_by_admins_only: Boolean

# Whether bookings at any time of the day are allowed
  is_bookable_outside_service_hours: Boolean

# Whether the repeat bookings are allowed
  can_have_repeat_bookings: Boolean

# Whether bookings of this resource can have invitees
  can_have_invitees: Boolean

# Minimum booking time (in seconds)
  min_booking_duration_sec: Int

# Maximum booking time (in seconds)
  max_booking_duration_sec: Int

# How much in advance a booking can be requested (in seconds or days, based on unit)
  min_advance_booking_time: Int

# Minimum advance time unit (seconds or days)
  min_advance_booking_unit: TimeUnit

# Users can book as close to the booking start time as they like
  set_no_min_advance_booking_time: Boolean = false

# How much in advance a booking can be requested (in seconds or days, based on unit)
  max_advance_booking_time: Int

# Maximum advance time unit (seconds or days)
  max_advance_booking_unit: TimeUnit

# Users can book as far in advance as they like
  set_no_max_advance_booking_time: Boolean = false

# The minimum time before the same user can book the resource again (in seconds)
  no_return_sec: Int

# The minimum time before users can book a resource again (in seconds)
  buffer_time_sec: Int

# How long before the booking start time a user can cancel, or edit the times (in seconds)
  editable_before_start_sec: Int
}

# Order of the resources
enum ResourceOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC

# Sort by the ability to be booked ASC
  IS_BOOKABLE_ASC

# Sort by the ability to be booked DESC
  IS_BOOKABLE_DESC

# Sort by the availability for drop-in bookings ASC
  IS_DROPIN_BOOKABLE_ASC

# Sort by the availability for drop-in bookings DESC
  IS_DROPIN_BOOKABLE_DESC

# Sort by location ASC
  LOCATION_ASC

# Sort by location DESC
  LOCATION_DESC

# Sort by type ASC
  TYPE_ASC

# Sort by type DESC
  TYPE_DESC

# Sort by type group ASC
  TYPE_GROUP_ASC

# Sort by type group DESC
  TYPE_GROUP_DESC

# Sort by capacity ASC
  CAPACITY_ASC

# Sort by capacity DESC
  CAPACITY_DESC

# Sort by creation date ASC
  CREATED_TIMESTAMP_ASC

# Sort by creation date DESC
  CREATED_TIMESTAMP_DESC

# Deprecated: use NAME_ASC
  TITLE_ASC

# Deprecated: use NAME_DESC
  TITLE_DESC

# Deprecated
  LOCATION_RATING_ASC

# Deprecated
  LOCATION_RATING_DESC
}

# Order of the resources
enum ResourceAvailabilityOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC

# Sort by score ASC
  SCORE_ASC

# Sort by score DESC
  SCORE_DESC

# Deprecated
  LOCATION_RATING_DESC
}

# Booking type for a resource
enum BookingAsType {
  DESK
  ROOM
  UNKNOWN
}

# Resource availability
type ResourceAvailability {
  resource: Resource!
  available_time_intervals: [TimeInterval!]!
  available: [TimeInterval!]! @deprecated(reason: "Replaced by available_time_intervals")
  available_time_slots: [AvailableTimeSlot!]!
  service_hours: [TimeInterval!]!
  assigned: [NamedTimeInterval!]!
  blocked: [NamedTimeInterval!]!
  booked: [BookedTimeInterval!]!
  buffer: [TimeInterval!]!
}

type ResourceAvailabilityGroup {
  name: String!
  type_group: ResourceTypeGroup
  resources: [ResourceAvailability!]!
  available_time_intervals: [TimeInterval!]!
  available: [TimeInterval!]! @deprecated(reason: "Replaced by available_time_intervals")
  available_time_slots: [AvailableTimeSlot!]!
}

type TimeInterval {
  start_timestamp: Int!
  end_timestamp: Int!
  start: Int! @deprecated(reason: "Replaced by start_timestamp")
  end: Int! @deprecated(reason: "Replaced by end_timestamp")
}

type BookedTimeInterval {
  start_timestamp: Int!
  end_timestamp: Int!
  account_name: String
  owner_name: String
  image: ImageSet
}

type NamedTimeInterval {
  start_timestamp: Int!
  end_timestamp: Int!
  name: String
}

type AvailableTimeSlot {
  start_timestamp: Int!
  end_timestamp: Int!
  name: String
}

input ResourceAvailabilityInput {
  resource: ResourceSearchInput

# Start timestamp (default: 1 week in the past)
  start_timestamp: Int

# End timestamp (default: 1 week in the future)
  end_timestamp: Int

# Minimum duration (in seconds)
  min_duration_sec: Int = 900

# Deprecated: replaced by min_duration_sec
  duration_sec: Int
  source: String
}

input ResourceSearchInput {
  resource_id: [ID!]
  name: String

# Filter by resource types
  resource_type_id: [ID!]

# Filter by resource type groups
  resource_type_group_id: [ID!]

# Deprecated: replaced by resource_type_group_id
  resource_group_id: [ID!]
  resource_type_time_id: [ID!]
  location_id: [ID!]
  capacity: Int
  capacity_from: Int
  capacity_to: Int
  min_booking_duration_sec: Int
  max_booking_duration_sec: Int
  price_hour: Float
  price_hour_from: Float
  price_hour_to: Float
  price_day: Float
  price_day_from: Float
  price_day_to: Float
  is_bookable: Boolean
  is_bookable_by_admins_only: Boolean
  is_bookable_outside_service_hours: Boolean
  booked_as: BookingAsType
  amenities: [String!]
  amenity_id: [ID!]

# Favorite resources of the current user
  only_favorite: Boolean = false
}

type ResourceFilters {
  filter_groups: [ResourceTypeGroup!]! @deprecated(reason: "Replaced by resource type groups")
  resource_types: [ResourceType!]!

# Resource type groups and the number of resources in each of them
  resource_type_groups: [ResourceTypeGroupWithQuantity!]!
  booking_groups: [ResourceTypeGroupWithQuantity!]! @deprecated(reason: "Replaced by resource_type_groups")
  time_slots: [TimeWithinWeekDay!]!

# Service hours of the resources (only if all resources belong to the same type)
  time_within_week_days: [TimeWithinWeekDay!]!
  capacity: [Int!]!
  price_hour: [Float!]!
  min_booking_duration_sec: [Int!]!
  max_booking_duration_sec: [Int!]!
  booked_as: [BookingAsType!]!
  is_bookable_outside_service_hours: [Boolean!]!
  amenities: [Amenity!]!
}

# Schedule event pagination wrapper
type ScheduleEventPagination {
# The number of available elements
  total: Int!

# If nothing found, try without the location filter applied
  found_in_all_locations: Boolean!
  total_in_all_locations: Int! @deprecated(reason: "Replaced by found_in_all_locations")

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of schedule events
  data: [ScheduleEvent!]!
}

type ScheduleEvent {
  type: ScheduleEventType!
  assignment_id: ID
  booking_id: ID
  tour_id: ID
  availability_block_id: ID
  resource: Resource
  location: Location
  owner_account: Account
  payer_account: Account
  start_timestamp: Int!
  end_timestamp: Int
  status: ScheduleEventStatus!
  is_recurring: Boolean!
  source: String

# Booking title, if exists
  title: String

# Tour calendar, if exists
  tour_calendar: Calendar

# Detailed time intervals for assignments and blocks, within the provided period
  time_intervals(from_timestamp: Int!, to_timestamp: Int!): [TimeInterval!]!

# Date created
  created_timestamp: Int!

# The user who created this event
  created_by_user: User
}

enum ScheduleEventType {
  AVAILABILITY_BLOCK
  ASSIGNMENT
  BOOKING
  EXTERNAL
  TOUR
}

enum ScheduleEventStatus {
  ACTIVE
  CANCELED
  ENDED
  UPCOMING
}

enum ScheduleEventOrder {
  RESOURCE_NAME_ASC
  RESOURCE_NAME_DESC
  OWNER_NAME_ASC
  OWNER_NAME_DESC
  TYPE_ASC
  TYPE_DESC
  START_TIMESTAMP_ASC
  START_TIMESTAMP_DESC
  STATUS_ASC
  STATUS_DESC
}

type ScheduleConflicts {
  total: Int!
  assignments: Int!
  blocks: Int!
  bookings: Int!
  external: Int!

# Up to 100 earliest conflicts
  events: [ScheduleEvent!]!
}

# Tag
type Tag {
# Tag unique ID
  tag_id: ID!

# Tag
  tag: String!
}

type TaskPagination {
  total: Int!

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")
  data: [Task!]!
}

type Task {
  task_id: ID!
  name: String!
  description: String
  assignee: User
  status: TaskStatus!
  labels: [Label!]!
  attachments: Attachments!
  is_recurring: Boolean!
  recurrence: Recurrence
  created_by: TaskCreator
  created_timestamp: Int!
  updated_timestamp: Int!
  due_timestamp: Int
  is_due: Boolean!
  completed_timestamp: Int
  deleted_timestamp: Int
}

union TaskCreator = User | Workflow

input TaskInput {
  name: String
  description: String
  assignee_user_id: ID
  set_no_assignee: Boolean
  status: TaskStatus
  label_id: [ID!]
  attachments: [AttachmentInput!]
  attachments_search: AttachmentSearchInput
  recurrence: RecurrenceInput
  due_timestamp: Int
  set_no_due_timestamp: Boolean
}

input TaskSearchInput {
# Filter by task ID
  task_id: [ID!]

# Search by task name, description, or assignee
  search: String

# Filter by assignee
  assignee_user_id: [ID!]

# Include tasks with no assignee
  include_unassigned: Boolean

# Filter by status
  status: [TaskStatus!]

# Filter by label
  label_id: [ID!]

# Filter by attachment
  attachments: [AttachmentInput!]

# Filter by author
  created_by_user: [ID!]

# Tasks created after the timestamp (inclusive)
  created_timestamp_from: Int

# Tasks created before the timestamp (inclusive)
  created_timestamp_to: Int

# Tasks due after the timestamp (inclusive)
  due_timestamp_from: Int

# Tasks due before the timestamp (inclusive)
  due_timestamp_to: Int

# Filter by being due
  is_due: Boolean
}

enum TaskStatus {
  TO_DO
  COMPLETED
  DELETED
}

# Order of the tasks
enum TaskOrder {
  ASSIGNEE_NAME_ASC
  ASSIGNEE_NAME_DESC
  NAME_ASC
  NAME_DESC
  STATUS_ASC
  STATUS_DESC
  CREATED_TIMESTAMP_ASC
  CREATED_TIMESTAMP_DESC
  DUE_TIMESTAMP_ASC
  DUE_TIMESTAMP_DESC
}

# Team, a group of users
type Team {
  team_id: ID!
  name: String!
  image: String

# Number of active users related to this team
  users_count: Int!

# All active users of the team, including admins
  users: [User!]

# All team admins
  admins: [User!]
}

# Team pagination wrapper
type TeamPagination {
# The number of available elements
  total: Int!

# List of teams
  data: [Team]!
}

# Order of the users
enum TeamOrder {
# Sorts ASC name
  NAME_ASC

# Sorts DESC name
  NAME_DESC

# Sorts ASC created
  CREATED_ASC

# Sorts DESC created
  CREATED_DESC
}

type TimelineEntryPagination {
# The number of available elements
  total: Int!

# List of timeline events
  data: [TimelineEntry]!
}

type TimelineEntry {
  event_id: ID!
  timestamp: Int!
  user_id: ID
  user: User
  action_token: String
  type: String
  ip_address: String
  description: String
  context: JsonString
}

# Tour pagination wrapper
type TourPagination {
# The number of available elements
  total: Int!

# List of tours
  data: [Tour!]!
}

type Tour {
# ID of the tour
  tour_id: ID!

# Location associated with this tour
  location: Location!

# The user who booked this tour
  user: User!
  start_timestamp: Int!
  end_timestamp: Int!
  created_timestamp: Int!
  is_canceled: Boolean!
  is_cancelled: Boolean! @deprecated(reason: "Replaced by is_canceled")

# Public tour confirmation link
  web_link: String
}

# A system user
type User {
# User unique ID
  user_id: ID!

# First name
  name: String

# Last name
  surname: String

# Fullname
  fullname: String

# Email
  email: String

# Phone
  phone: String

# City
  city: String

# Country
  country: String

# Skype
  skype: String

# Twitter
  twitter: String

# Linkedin
  linkedin: String

# Website
  website: String

# Mobile devices associated with this user
  devices: [Device]!

# Profile image
  image: ImageSet!
  picture: ImageSet! @deprecated(reason: "Replaced by image")

# User-defined company name
  company: String

# Job title
  title: String

# User-defined professional headline
  profession: String

# Biography
  bio: String

# Skills
  skills: [String!]

# List of active bookings created by this user
  bookings(
# Number of elements per page
    limit: Int = 100

# Page
    page: Int = 1

# Order by
    order: BookingOrder

# Includes new bookings
    include_new: Boolean

# Includes approved bookings
    include_approved: Boolean

# Includes completed bookings (deprecated)
    include_completed: Boolean

# Includes canceled bookings
    include_canceled: Boolean

# Includes canceled bookings (deprecated: replaced by include_canceled)
    include_cancelled: Boolean

# Includes rejected bookings
    include_rejected: Boolean

# Only associated with specific resources
    resource_id: [ID]

# Only associated with specific locations
    location_id: [ID]

# Bookings starting after the timestamp (inclusive)
    start_timestamp_from: Int

# Bookings starting before the timestamp (inclusive)
    start_timestamp_to: Int

# Bookings ending after the timestamp (inclusive)
    end_timestamp_from: Int

# Bookings ending before the timestamp (inclusive)
    end_timestamp_to: Int

# Deprecated: use start_timestamp_from
    start_from: Int

# Deprecated: use start_timestamp_to
    start_to: Int

# Includes bookings the current user was invited to
    invited: [InviteeStatus!]
    booked_as: BookingAsType
    in_progress: Boolean
    is_hidden: Boolean
  ): BookingPagination!
  teams: [Team]

# Account contracts connect users to their member or team accounts
  account_contracts(include_hidden: Boolean = false): [AccountContract!]!

# Legacy member unique ID
  member_id: Int @deprecated(reason: "Consider using user_id to refer to this user, and account_id to refer to the billing data")

# Indicates whether the user is active
  is_active: Boolean

# If the user is marked as inactive, any interaction by this user will make him active again
  is_inactive: Boolean

# This user has been deleted
  is_deleted: Boolean

# This user is marked as a lead
  is_lead: Boolean!

# This user didn't complete the onboarding process
  is_pending: Boolean

# Indicates whether the user is allowed to book
  is_allowed_to_book: Boolean

# Indicates whether the user is allowed to check in
  is_allowed_to_checkin: Boolean

# Indicates whether the user is an organization admin
  is_admin: Boolean

# Date of the first interaction of this user as active or lead
  user_since: Int

# Conversation for contacting the admins
  user_to_admins_conversation_id: ID

# User properties
  properties(
# Filter by property ID
    property_id: [ID!]
  ): [PropertyValue!]!

# Whether the user has active of upcoming plans
  has_plans: Boolean!

# Whether the user has any wallet accesses
  has_accesses: Boolean!

# The active check-ins of the user
  active_checkins(
# Filter by location ID
    location_id: [ID!]
  ): [Checkin!]!
}

type AccountContract {
  account: Account!
  is_admin: Boolean!
  organization: Organization!
  team: Team
}

type AccountPermissions {
  can_book: Boolean!
  can_checkin: Boolean!
  missing_payment: Boolean!
  missing_plan_and_allowance: Boolean!
  missing_required_profile: Boolean!
  missing_required_property: Boolean!
  missing_team_payment: Boolean!
}

# Authentication type
enum TokenType {
# Not authenticated
  ANONYMOUS

# Authenticated using a legacy token
  LEGACY

# Authenticated using a personal token, usually for client-server communication
  PERSONAL

# Authenticated using an organization token, usually for server-server communication
  ORGANIZATION

# Not expected: requests made with the expired tokens are considered anonymous
  EXPIRED

# Authorized for a single action
  SINGLE_ACTION
}

# Current authenticated user
type AuthenticatedUser {
# Current method of authentication
  authType: TokenType!

# Current user; NULL if you are using an organization token
  user: User

# Current organization; NULL if you are not using a token associated with an organization
  organization: Organization

# Capabilities available to the current user, check the developer documentation for the full list
  capabilities(capabilities_to_check: [String]!): [String]!
  account_status: AccountPermissions

# For admins only
  admin: Admin
}

# Mobile device
type Device {
# Device ID
  device_id: String!

# Device model
  model: String!

# OS version
  os_version: String!

# App version
  app_version: String!

# Registration date
  registration_timestamp: Int!
}

# User pagination wrapper
type UserPagination {
# The number of available elements
  total: Int!

# List of users
  data: [User]!
}

# Order of the users
enum UserOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC

# Sort by user creation timestamp ASC
  MEMBER_CREATION_ASC

# Sort by user creation timestamp DESC
  MEMBER_CREATION_DESC
}

type UserPasswordStrength {
  is_strong: Boolean!
  message: String
}

type UserSignupSummary {
  account_plan: AccountPlan
  product_sale: ProductSale
  invoices: [ChangeInvoice!]!
}

type UserAccessPagination {
# The number of available elements
  total: Int!

# List of resources
  data: [UserAccess]!
}

type UserAccess {
  user_id: ID!
  email: String!
  name: String
  surname: String
  access_templates: [AccessTemplate!]
}

type Wallet {
  wallet_id: ID!
  type: WalletType!
  name: String!
  image: String
  accesses: [AvailableWalletAccess!]!
  access_templates: [AccessTemplate!]!
}

type AvailableWalletAccess {
  access_template: AccessTemplate!
  access_usage_user: User
  unlimited_allowance: Boolean!
  discount_pct: Float!
  allowances: [AvailableAllowance!]!
}

type AvailableAllowance {
  unit: Unit!
  available: Float!
}

enum WalletType {
  USER
  TEAM
}

input AvailableAllowanceInput {
  unit_id: ID!
  available: Float!
}

type WalletAccessUsage {
  access_template: AccessTemplate!
  type: WalletAccessType!
  unit: Unit
  allowance_used: Float
  unlimited_allowance: Boolean!
  discount_pct: Float
}

enum WalletAccessType {
  ALLOWANCE
  UNLIMITED_ALLOWANCE
  DISCOUNT
}

input WalletAccessAuditSearchInput {
  source: [WalletAccessAuditSource!]
  object_type: [ObjectType!]
  created_by_user_id: ID
  timestamp_from: Int
  timestamp_to: Int
}

type WalletAccessAuditPagination {
  total: Int!
  found_without_filters: Boolean!
  data: [WalletAccessAudit!]!
}

type WalletAccessAudit {
  wallet_access_audit_id: ID!
  source: WalletAccessAuditSource!
  object_type: ObjectType!
  object_id: ID!
  object: WalletAccessAuditObject!
  created_by_user: User
  value: Float!
  unit: Unit!
  timestamp: Int!
}

union WalletAccessAuditObject = AccountPlan | Booking | Checkin | ProductSale | User | Workflow

# Webhook job description
type WebhookJob {
# Job unique ID
  id: ID!

# Event
  event: String!

# Request payload
  payload: String!

# Target URL
  url: String!

# Date that the job was queued
  created_timestamp: Int!

# Next scheduled execution
  retry_timestamp: Int

# Number of retries
  retry_count: Int!

# Current status
  status: WebhookStatus!

# Debug log
  log: String!
}

type WebhookJobPagination {
# The number of available elements
  total: Int!

# List of jobs
  data: [WebhookJob]!
}

enum WebhookType {
# Pending
  PENDING

# Executed
  EXECUTED
}

enum WebhookStatus {
# The webhook is pending
  PENDING

# The webhook has succeeded
  SUCCESS

# The webhook has failed
  FAIL

# The webhook was canceled
  CANCELED
}

# Order of the automations
enum WorkflowOrder {
# Sort by name ASC
  NAME_ASC

# Sort by name DESC
  NAME_DESC

# Sort by trigger type ASC
  TRIGGER_TYPE_ASC

# Sort by trigger type DESC
  TRIGGER_TYPE_DESC

# Sort by creation date ASC
  CREATED_TIMESTAMP_ASC

# Sort by creation date DESC
  CREATED_TIMESTAMP_DESC

# Sort by last edit date ASC
  UPDATED_TIMESTAMP_ASC

# Sort by last edit date DESC
  UPDATED_TIMESTAMP_DESC

# Sort by latest enrollment date ASC
  LATEST_ENROLLMENT_TIMESTAMP_ASC

# Sort by latest enrollment date DESC
  LATEST_ENROLLMENT_TIMESTAMP_DESC

# Sort by enrollment count ASC
  ENROLLMENT_COUNT_ASC

# Sort by enrollment count DESC
  ENROLLMENT_COUNT_DESC
}

# Order of the automation enrollments
enum WorkflowEnrollmentOrder {
# Sort by enrollment date ASC
  CREATED_TIMESTAMP_ASC

# Sort by enrollment date DESC
  CREATED_TIMESTAMP_DESC
}

input WorkflowSearchInput {
# Filter by automation ID
  workflow_id: [ID!]

# Search by name or description
  search: String

# Filter by trigger type
  trigger_type: [WorkflowTriggerType!]

# Filter by status
  is_paused: Boolean

# Filter default workflows
  is_default: Boolean

# Filter by label
  label_id: [ID!]
}

# Automation pagination wrapper
type WorkflowPagination {
# The number of available elements
  total: Int!

# If nothing found, try without any filters applied
  found_without_filters: Boolean!
  total_without_filters: Int! @deprecated(reason: "Replaced by found_without_filters")

# List of automations
  data: [Workflow!]!
}

type Workflow {
  workflow_id: ID!
  name: String!
  description: String
  goal: String
  time_saving_minutes: Int
  is_paused: Boolean!
  is_default: Boolean!
  trigger_type: WorkflowTriggerType!
  labels: [Label!]!

# Type of an automation recipe
  recipe_type: WorkflowRecipeType
  current_version: WorkflowVersion!
  versions: [WorkflowVersion!]!
  latest_enrollment_timestamp: Int
  enrollment_count: Int!
  some_enrolled_users: [User!]
  created_by_user: User!
  created_timestamp: Int!
  updated_timestamp: Int!
  is_deleted: Boolean!
}

type WorkflowRecipe {
  name: String
  is_paused: Boolean!
  is_used: Boolean!

# Type of an automation recipe
  recipe_type: WorkflowRecipeType!
  requires_automations_plus: Boolean!
  has_default_condition: Boolean!
  trigger_type: WorkflowTriggerType!
  steps: [WorkflowStep!]!

# Automation based on the recipe
  workflow: Workflow
}

input WorkflowInput {
  name: String
  description: String
  goal: String
  time_saving_minutes: Int
  is_paused: Boolean
  is_new_version: Boolean = true
  label_id: [ID!]
  steps: [WorkflowStepInput!]
  has_default_condition: Boolean
  version_name: String
  recipe_type: WorkflowRecipeType
}

type WorkflowVersion {
  workflow_version_id: ID!
  number: Int!
  name: String
  is_current: Boolean!
  has_default_condition: Boolean!
  trigger_type: WorkflowTriggerType!
  steps: [WorkflowStep!]!
  created_by_user: User!
  created_timestamp: Int!
  updated_timestamp: Int!
}

interface WorkflowStep {
  workflow_step_id: ID!
  requires_automations_plus: Boolean!
}

input WorkflowStepInput {
  trigger_type: WorkflowTriggerType
  condition_operation: ConditionOperation
  condition_parameters: [ConditionParameterInput!]
  conditions: [WorkflowStepInput!]
  delay_for: DurationInput
  delay_until: ConditionParameterInput
  action_type: WorkflowActionType
  add_allowance: WorkflowActionAllowanceInput
  add_invoice_item: WorkflowActionInvoiceItemInput
  add_to_group_conversation: WorkflowActionGroupConversationInput
  change_account_type: WorkflowActionAccountTypeInput
  change_primary_location: WorkflowActionPrimaryLocationInput
  change_user_status: WorkflowActionUserStatusInput
  create_task: WorkflowActionTaskInput
  post_to_feed: WorkflowActionPostInput
  send_doc_to_sign: WorkflowActionDocToSignInput
  send_email: WorkflowActionEmailInput
  send_message: WorkflowActionMessageInput
}

type WorkflowTrigger implements WorkflowStep {
  workflow_step_id: ID!
  trigger_type: WorkflowTriggerType!
  requires_automations_plus: Boolean!

# Variables provided by the trigger
  variables: [EvaluableVariable!]!
  default_condition: WorkflowCondition
}

type WorkflowCondition implements WorkflowStep {
  workflow_step_id: ID!
  requires_automations_plus: Boolean!
  condition_operation: ConditionOperation!
  condition_parameters: [ConditionParameter!]
  conditions: [WorkflowCondition!]
}

type WalletAllowanceVariableParameters {
  unit_id: ID
  access_template_id: ID
}

input WalletAllowanceVariableParametersInput {
  unit_id: ID!
  access_template_id: ID!
}

type WorkflowDelay implements WorkflowStep {
  workflow_step_id: ID!
  requires_automations_plus: Boolean!

# Fixed delay from the moment the execution reaches this step (minutes, hours, days, weeks, or months)
  delay_for: Duration

# Dynamic delay until the moment defined by a fixed value, a variable, or a user property
  delay_until: ConditionParameter
}

type WorkflowAction implements WorkflowStep {
  workflow_step_id: ID!
  action_type: WorkflowActionType!
  requires_automations_plus: Boolean!
  add_allowance: WorkflowActionAllowance
  add_invoice_item: WorkflowActionInvoiceItem
  add_to_group_conversation: WorkflowActionGroupConversation
  change_account_type: WorkflowActionAccountType
  change_primary_location: WorkflowActionPrimaryLocation
  change_user_status: WorkflowActionUserStatus
  create_task: WorkflowActionTask
  post_to_feed: WorkflowActionPost
  send_doc_to_sign: WorkflowActionDocToSign
  send_email: WorkflowActionEmail
  send_message: WorkflowActionMessage
}

type WorkflowActionAllowance {
  access_template_id: ID!
  unlimited_allowance: Boolean
  allowance: Float
  allowance_unit_id: ID
  allowance_expire_days: Int
  due_on_following_billing_date: Boolean
  unit_amount: Float
  target_account_id: ID
}

input WorkflowActionAllowanceInput {
  access_template_id: ID!
  unlimited_allowance: Boolean
  allowance: Float
  allowance_unit_id: ID
  allowance_expire_days: Int
  due_on_following_billing_date: Boolean
  unit_amount: Float
  target_account_id: ID
}

type WorkflowActionGroupConversation {
  target_group_conversation_id: ID!
  target_team_admins: Boolean
}

input WorkflowActionGroupConversationInput {
  target_group_conversation_id: ID!
  target_team_admins: Boolean
}

type WorkflowActionTask {
  name: String!
  description: String
  assignee_user_id: ID
  set_assignee_primary_location_admin: Boolean
  set_no_due_timestamp: Boolean
  to_due: Duration
}

input WorkflowActionTaskInput {
  name: String!
  description: String
  assignee_user_id: ID
  set_assignee_primary_location_admin: Boolean
  set_no_due_timestamp: Boolean
  to_due: DurationInput
}

type WorkflowActionUserStatus {
  status: AccountStatus
}

input WorkflowActionUserStatusInput {
  status: AccountStatus
}

type WorkflowActionAccountType {
  type_label_id: ID!
}

input WorkflowActionAccountTypeInput {
  type_label_id: ID!
}

type WorkflowActionPrimaryLocation {
  location_id: ID!
}

input WorkflowActionPrimaryLocationInput {
  location_id: ID!
}

type WorkflowActionInvoiceItem {
  name: String
  description: String
  tax_rate: Float
  inclusive_tax_rate: Float
  unit_amount: Float
  quantity: Float
  due_on_following_billing_date: Boolean!
}

input WorkflowActionInvoiceItemInput {
  name: String
  description: String
  tax_rate: Float
  inclusive_tax_rate: Float
  unit_amount: Float
  quantity: Float
  due_on_following_billing_date: Boolean!
}

type WorkflowActionEmail {
  subject: String
  body: String!

# Send an email to a specific admin; otherwise, to the account that triggered an automation
  target_admin_user_id: ID

# When sending an email to a team, the recipients are only team admins; otherwise, all team members
  target_team_admins: Boolean
  notification_type: String
  mail_provider_credentials_id: ID
}

input WorkflowActionEmailInput {
  subject: String
  body: String!

# Send an email to a specific admin; otherwise, to the account that triggered an automation
  target_admin_user_id: ID

# When sending an email to a team, the recipients are only team admins; otherwise, all team members
  target_team_admins: Boolean
  notification_type: String
  mail_provider_credentials_id: ID
}

type WorkflowActionMessage {
# Send a message from a specific admin; otherwise, from the account's primary location admin
  from_admin_user_id: ID

# When sending a message to a team, the recipients are only team admins; otherwise, all team members
  target_team_admins: Boolean

# Send a message to the support chat or send it as a private message
  target_support_chat: Boolean

# Send a message to a specific admin; otherwise, to the account that triggered an automation
  target_admin_user_id: ID

# Send a message to an existing group conversation; otherwise, to the account that triggered an automation
  target_group_conversation_id: ID
  message: String!
}

input WorkflowActionMessageInput {
# Send a message from a specific admin; otherwise, from the account's primary location admin
  from_admin_user_id: ID

# When sending a message to a team, the recipients are only team admins; otherwise, all team members
  target_team_admins: Boolean

# Send a message to the support chat or send it as a private message
  target_support_chat: Boolean = false

# Send a message to a specific admin; otherwise, to the account that triggered an automation
  target_admin_user_id: ID

# Send a message to an existing group conversation; otherwise, to the account that triggered an automation
  target_group_conversation_id: ID
  message: String!
}

type WorkflowActionPost {
  message: String!
  created_by_admin_id: ID
  image_url: String
  location_id: [ID!]
  in_all_locations: Boolean
  send_notification: Boolean
}

input WorkflowActionPostInput {
  message: String!
  created_by_admin_id: ID
  image_url: String
  location_id: [ID!]
  in_all_locations: Boolean = true
  send_notification: Boolean = false
}

type WorkflowActionDocToSign {
  name: String!
  contents_url: String
  contents_origin_name: String
  contents: String
  include_entity_summary: Boolean!
  include_entity_terms: Boolean!
  admin_signer_user_id: ID
  primary_location_admin_is_signer: Boolean
  payer_is_signer: Boolean!
}

input WorkflowActionDocToSignInput {
  name: String!
  contents_url: String
  contents_origin_name: String
  contents: String
  include_entity_summary: Boolean!
  include_entity_terms: Boolean!
  admin_signer_user_id: ID
  primary_location_admin_is_signer: Boolean
  payer_is_signer: Boolean!
}

type WorkflowEnrollmentPagination {
# The number of available elements
  total: Int!

# List of automation enrollments
  data: [WorkflowEnrollment!]!
}

type WorkflowEnrollment {
  workflow_enrollment_id: ID!
  version: WorkflowVersion!
  workflow: Workflow!
  account: Account
  status: WorkflowEnrollmentStatus!
  trigger_metadata: WorkflowEnrollmentTriggerMetadata
  steps_metadata: [WorkflowEnrollmentStepMetadata!]!
  created_timestamp: Int!
  updated_timestamp: Int!
  completed_timestamp: Int
  stopped_timestamp: Int
  unenrolled_timestamp: Int
  error_timestamp: Int
  last_error: String
}

# Metadata for a given enrollment step
type WorkflowEnrollmentStepMetadata {
# Related step
  workflow_step_id: ID!

# Related overridden step
  workflow_overridden_step_id: ID

# When the execution of the step started
  started_timestamp: Int!

# For delay steps, when the delay is expected to end
  delay_until_timestamp: Int

# When the execution of the step completed
  completed_timestamp: Int

# Notes about the execution of the step: errors, partial completion, etc.
  log: String
  step: WorkflowStep
}

# Metadata for an enrollment trigger
type WorkflowEnrollmentTriggerMetadata {
  object_type: ObjectType
  object_id: ID
  title: String!
}

input WorkflowEnrollmentSearchInput {
# Filter by automation ID
  workflow_id: [ID!]

# Filter by automation version ID
  workflow_version_id: [ID!]

# Filter by enrollment ID
  workflow_enrollment_id: [ID!]

# Filter by enrolled account ID
  account_id: [ID!]

# Filter by status
  status: [WorkflowEnrollmentStatus!]

# Search by account name
  search: String

# Enrollments created after the timestamp (inclusive)
  created_timestamp_from: Int

# Enrollments created before the timestamp (inclusive)
  created_timestamp_to: Int
}

type WorkflowEmailDraft {
  subject: String!
  body: String!
  from_name: String
  from_address: String
  reply_to_name: String
  reply_to_address: String
}

# Directions for ordering a list of records.
enum SortOrder {
# Sort records in ascending order.
  ASC

# Sort records in descending order.
  DESC
}

# Aggregate functions when ordering by a relation without specifying a column.
enum OrderByRelationAggregateFunction {
# Amount of items.
  COUNT
}

# Aggregate functions when ordering by a relation that may specify a column.
enum OrderByRelationWithColumnAggregateFunction {
# Average.
  AVG

# Minimum.
  MIN

# Maximum.
  MAX

# Sum.
  SUM

# Amount of items.
  COUNT
}

# Allows ordering a list of records.
input OrderByClause {
# The column that is used for ordering.
  column: String!

# The direction that is used for ordering.
  order: SortOrder!
}

# Specify if you want to include or exclude trashed results from a query.
enum Trashed {
# Only return trashed results.
  ONLY

# Return both trashed and non-trashed results.
  WITH

# Only return non-trashed results.
  WITHOUT
}
